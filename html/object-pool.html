<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />

<title>Game Programming Patterns / Optimization Patterns / Object Pool</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />
<link href="http://fonts.googleapis.com/css?family=Source+Code+Pro|Source+Sans+Pro:200,300,400,600,400italic,600italic|Rock+Salt" rel="stylesheet" type="text/css">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-1', 'gameprogrammingpatterns.com');
  ga('send', 'pageview');
</script>
</head>
<body id="top">
<div class="nav">
  <div class="bar">
    <div class="column">
      <h1 class="thread">&larr; <a href="dirty-flag.html">Dirty Flag</a> | <a href="spatial-partition.html">Spatial Partition</a> &rarr;
      <h1>&equiv; <a href="index.html">Game Programming Patterns</a></h1>
    </div>
  </div>
  <div class="column">
    <table>
      <tr>
        <td width="30%" class="section-nav">
          <h2>Object Pool</h2>
          <ul><li>
<a href="#intent">Intent</a></li><li>
<a href="#motivation">Motivation</a></li><li>
<a href="#the-pattern">The Pattern</a></li><li>
<a href="#when-to-use-it">When to Use It</a></li><li>
<a href="#keep-in-mind">Keep in Mind</a></li><li>
<a href="#sample-code">Sample Code</a></li><li>
<a href="#design-decisions">Design Decisions</a></li><li>
<a href="#see-also">See Also</a></li></ul>

        </td>
        <td width="70%">
          <h2>Chapters</h2>
<ul>
  <li><a href="introduction.html">Introduction</a>
    <ul>
      <li><a href="architecture-performance-and-games.html">Architecture, Performance, and Games</a></li>
    </ul>
  </li>
  <li><a href="design-patterns-revisited.html">Design Patterns Revisited</a>
    <ul>
      <li><a href="command.html">Command</a>,
        <a href="flyweight.html">Flyweight</a>,
        <a href="observer.html">Observer</a>,
        <a href="prototype.html">Prototype</a>,
        <a href="singleton.html">Singleton</a>,
        <a href="state.html">State</a></li>
    </ul>
  </li>
  <li><a href="sequencing-patterns.html">Sequencing Patterns</a>
    <ul>
      <li><a href="double-buffer.html">Double Buffer</a>,
        <a href="game-loop.html">Game Loop</a>,
        <a href="update-method.html">Update Method</a></li>
    </ul>
  </li>
  <li><a href="behavioral-patterns.html">Behavioral Patterns</a>
    <ul>
      <li><a href="bytecode.html">Bytecode</a>,
      <a href="subclass-sandbox.html">Subclass Sandbox</a>,
      <a href="type-object.html">Type Object</a></li>
    </ul>
  </li>
  <li><a href="decoupling-patterns.html">Decoupling Patterns</a>
    <ul>
      <li><a href="component.html">Component</a>,
        <a href="event-queue.html">Event Queue</a>,
        <a href="service-locator.html">Service Locator</a></li>
    </ul>
  </li>
  <li><a href="optimization-patterns.html">Optimization Patterns</a>
    <ul>
      <li><a href="data-locality.html">Data Locality</a>,
      <a href="dirty-flag.html">Dirty Flag</a>,
      <a href="object-pool.html">Object Pool</a>,
      <a href="spatial-partition.html">Spatial Partition</a></li>
    </ul>
  </li>
</ul>
        </td>
      </tr>
    </table>
  </div>
</div>
<div class="page sidebar">
<div class="content">
<div class="in-progress">
  <span class="dismiss">&times;</span>
  <h2>This book is a work in progress!</h2>

  <p>If you see a mistake, find something unclear, or have a suggestion, please <a href="https://github.com/munificent/game-programming-patterns/issues" target="_blank">file a ticket</a>. To know when new chapters are up, join the mailing list:</p>

  <!-- Begin MailChimp Signup Form -->
  <div id="mc_embed_signup">
  <form action="http://gameprogrammingpatterns.us7.list-manage.com/subscribe/post?u=0952ca43ed2536d6717766b88&amp;id=0c27329244" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
    <table>
      <tr>
        <td width="100%">
          <input type="email" value="" name="EMAIL" class="email" id="mce-EMAIL" placeholder="email address" required>
        </td>
        <td>
          <div class="spacer"></div>
        </td>
        <td>
          <input type="submit" value="Join" name="subscribe" id="mc-embedded-subscribe" class="button">
        </td>
      </tr>
    </table>
  </form>
  </div>
  <!--End mc_embed_signup-->

  <table width="100%">
    <tr>
      <td width="50%">
        <p>Thank you!</p>
      </td>
      <td width="50%">
        <p class="signature">&mdash; Bob Nystrom (<a href="https://twitter.com/intent/user?screen_name=munificentbob" target="_blank">@munificentbob</a>)</p>
      </td>
    </tr>
  </table>
</div>
<h1>Object Pool</h1>
<h1 class="book"><a href="index.html">Game Programming Patterns</a><span class="section"><a href="optimization-patterns.html">Optimization Patterns</a></span></h1>
<h2><a href="#intent" name="intent">Intent</a></h2>
<p><em>Improve performance and memory use by reusing objects from a fixed
pool instead of allocating and freeing them individually.</em></p>
<h2><a href="#motivation" name="motivation">Motivation</a></h2>
<p>We&#x2019;re working on the visual effects for our game. When the hero casts
a spell, we want a shimmer of sparkles to burst across the screen.
This calls for a <em>particle system</em>: an engine that spawns little
sparkly graphics and animates them until they wink out of existence.</p>
<p>Since a single wave of the wand could cause hundreds of particles to
be spawned, our system needs to be able to create them very quickly.
More importantly, we need to make sure that creating and destroying
these particles doesn&#x2019;t cause <em>memory fragmentation</em>.</p>
<h3><a href="#the-curse-of-fragmentation" name="the-curse-of-fragmentation">The curse of fragmentation</a></h3>
<p>Programming for a game console like the XBox 360 is closer to embedded
programming than conventional PC programming in many ways. Like
embedded programming, console games must run continuously for a very
long time without crashing or leaking memory and efficient compacting
memory managers are rarely available. In this environment memory
fragmentation is deadly.</p>
<p>Fragmentation means the free space in our heap is <span name="park">broken</span> into smaller
pieces of memory instead of one large open block. The
<em>total</em> memory available may be large, but the largest
<em>contiguous</em> region might be painfully small. Say we&#x2019;ve got
fourteen bytes free, but it&#x2019;s fragmented into two seven-byte pieces with a
chunk of in-use memory between them. If we try to allocate a twelve-byte
object, we&#x2019;ll fail. No more sparklies onscreen.</p>
<aside name="park">

<p>Have you ever tried to parallel park on a busy street where the
already parked cars are spaced out just a <em>little</em> bit too far? If
they could just bunch up, there&#x2019;d be room for your car, but the free
space is divided up into bits of open curb between half a dozen cars.
That&#x2019;s fragmentation.</p>
</aside>

<p><span name="heap"></span></p>
<p><img src="images/object-pool-heap-fragment.png" /></p>
<aside name="heap">

<p>Here&#x2019;s how a heap becomes fragmented, and how it can cause an
allocation to fail even where there&#x2019;s theoretically enough memory
available.</p>
</aside>

<p>Even if fragmentation is infrequent, it can still <span name="soak">gradually</span> reduce the
heap to an unusable foam of open holes and filled-in crevices,
ultimately hosing the game completely.</p>
<aside name="soak">

<p>Most console makers require games to pass &ldquo;soak tests&rdquo;
where they leave the game running in demo mode for several days. If
the game crashes, they don&#x2019;t allow it to ship. While soak tests
sometimes fail because of a rarely-occurring bug, it&#x2019;s usually
creeping fragmentation or memory leakage that brings the game down.</p>
</aside>

<h3><a href="#the-best-of-both-worlds" name="the-best-of-both-worlds">The best of both worlds</a></h3>
<p>Because of fragmentation, and because allocation may be slow, games are very
careful about when and how they manage memory. A simple solution is
often best: grab a big chunk of memory when the game starts and don&#x2019;t
free it until the game ends. But this is a pain for systems where we
need to create and destroy things while the game is running.</p>
<p>An object pool gives us the best of both worlds: to the memory
manager, we&#x2019;re just allocating one big hunk of memory up front and not
freeing it while the game is playing. To the users of the pool, we
can freely allocate and deallocate objects to our heart&#x2019;s content.</p>
<h2><a href="#the-pattern" name="the-pattern">The Pattern</a></h2>
<p>Define a <strong>pool</strong> class that maintains a collection of <strong>reusable
objects</strong>. Each object supports an <strong>&ldquo;in use&rdquo; query</strong> to
tell if it is currently &ldquo;alive.&rdquo; When the pool is
initialized, it creates the entire collection of objects up front
(usually in a single contiguous allocation) and initializes them all
to the &ldquo;not in use&rdquo; state.</p>
<p>When you want a new object, ask the pool for one. It finds an
available object, initializes it to &ldquo;in use&rdquo; and returns
it. When the object is no longer needed, it is set back to the
&ldquo;not in use&rdquo; state. This way, objects can be freely
created and destroyed without needing to allocate memory or other
resources.</p>
<h2><a href="#when-to-use-it" name="when-to-use-it">When to Use It</a></h2>
<p>This pattern is used widely in games for obvious things like game
entities and visual effects, but also for less visible data structures
such as currently playing sounds. Use Object Pool when:</p>
<ul>
<li>
<p>You need to frequently create and destroy objects.</p>
</li>
<li>
<p>They are similar in size.</p>
</li>
<li>
<p>Allocating them on the heap is slow or could lead to memory
    fragmentation.</p>
</li>
<li>
<p>Each object encapsulates a resource such as a database or network
    connection that is slow to acquire and could be reused.</p>
</li>
</ul>
<h2><a href="#keep-in-mind" name="keep-in-mind">Keep in Mind</a></h2>
<h3><a href="#the-pool-may-waste-memory-on-unneeded-objects" name="the-pool-may-waste-memory-on-unneeded-objects">The pool may waste memory on unneeded objects</a></h3>
<p>The size of an object pool needs to be tuned for the game&#x2019;s needs.
When tuning, it&#x2019;s usually obvious when the pool is too <em>small</em>
(there&#x2019;s nothing like a crash to get your attention). But also take
care that the pool isn&#x2019;t too <em>big</em>. A smaller pool frees up memory
that could be used for other fun stuff.</p>
<h3><a href="#only-a-fixed-number-of-objects-can-be-active-at-any-one-time" name="only-a-fixed-number-of-objects-can-be-active-at-any-one-time">Only a fixed number of objects can be active at any one time</a></h3>
<p>In some ways this is a good thing. Partitioning memory into
separate pools for different types of objects ensures that, for
example, a huge sequence of explosions won&#x2019;t cause your particle
system to eat <em>all</em> of the available memory, preventing something more
critical like a new enemy from being created.</p>
<p>Nonetheless, this also means being prepared for the possibility that
your attempt to reuse an object from the pool will fail because they
are all in use. There are a couple of common strategies to handle
this.</p>
<ol>
<li>
<p><em>Prevent it outright.</em> This is the most common &ldquo;fix&rdquo;:
    tune the pool sizes so that they never overflow regardless of what
    the user does. For pools of important objects like enemies or
    gameplay items, this is often the right answer. There may be no
    &ldquo;right&rdquo; way to handle the lack of a free slot to
    create the big boss when the player reaches the end of the level,
    so the smart thing to do is make sure that never happens.</p>
<p>The downside is that this can force you to sit on a lot of memory
for object slots that are needed only for a couple of rare edge
cases. Because of this, a single fixed pool size may not be the
best fit for all game states. For instance, some levels may
feature effects prominently while others focus on sound. In such
cases, consider having pool sizes tuned differently for each
scenario.</p>
</li>
<li>
<p><em>Just don&#x2019;t create the object.</em> This sounds harsh, but it makes
    sense for cases like our particle system. If all particles are in
    use, the screen is probably full of flashing graphics. The user
    won&#x2019;t notice if the next explosion isn&#x2019;t quite as impressive as
    the ones currently going off.</p>
</li>
<li>
<p><em>Forcibly kill an existing object.</em> Consider a pool for currently
    playing sounds, and assume you want to start a new sound but the
    pool is full. You do <em>not</em> want to simply ignore the new sound:
    the user will notice if their magical wand swishes dramatically
    <em>sometimes</em> and stay stubbornly silent other times. A better
    solution is to find the quietest sound already playing and replace
    that with our new sound. The new sound will mask the audible
    cutoff of the previous sound.</p>
<p>In general, if the <em>disappearance</em> of an existing object would be
less noticeable than the <em>absence</em> of a new one, this may be the
right choice.</p>
</li>
<li>
<p><em>Increase the size of the pool.</em> If your game lets you be a bit
    more flexible with memory, you may be able to increase the size of
    the pool at runtime, or create a second overflow pool. If you do
    grab more memory in either of these ways, consider whether or not
    the pool should contract to its previous size when the additional
    capacity is no longer needed.</p>
</li>
</ol>
<h3><a href="#memory-size-for-each-object-is-fixed" name="memory-size-for-each-object-is-fixed">Memory size for each object is fixed</a></h3>
<p>Most pool implementations store the objects in an array of in-
place objects. If all of your objects are of the same type, this is
fine. However, if you want to store objects of different types in the
pool, or instances of subclasses that may add fields, you need to
ensure that each slot in the pool has enough memory for the <em>largest</em>
possible object. Otherwise, an unexpectedly large object will stomp
over the next one and trash memory.</p>
<p>At the same time, when your objects vary in size, you waste memory.
Each slot needs to be big enough to accomodate the largest object. If
objects are rarely that big, you&#x2019;re throwing away memory every time
you put a smaller one in that slot. It&#x2019;s like going through airport
security and using a huge carry-on-sized luggage tray just for your
keys and wallet.</p>
<p>When you find yourself burning a lot of memory this way, consider
splitting the pool into <span name="pools">separate</span> pools for different sizes of
object&thinsp;&mdash;&thinsp;big trays for luggage, little trays for pocket stuff.</p>
<aside name="pools">

<p>This is a common pattern for implementing speed-efficient memory
managers. The manager has a number of pools of different block sizes.
When you ask it to allocate a block, it finds in an open slot in the
pool of the appropriate size and allocates from that pool.</p>
</aside>

<h3><a href="#reused-objects-aren&#x2019;t-automatically-cleared" name="reused-objects-aren&#x2019;t-automatically-cleared">Reused objects aren&#x2019;t automatically cleared</a></h3>
<p>Most memory managers have a debug feature that will clear freshly
allocated or freed memory to some obvious magic value like
<code>0xdeadbeef</code>. This helps you find painful bugs caused by uninitialized
variables or using memory after it&#x2019;s freed.</p>
<p>Since our object pool isn&#x2019;t going through the memory manager any more
when it reuses an object, we lose that safety net. Worse, the memory
used for a &ldquo;new&rdquo; object previously held an object of the
exact same type. This makes it nearly impossible to tell if you forgot
to initialize something when you created the new object: the memory
where the object is stored may already contain <em>almost</em> correct data
from its past life.</p>
<p>Because of this, pay special care that the code that initializes new
objects in the pool <em>fully</em> initializes the object. It may even be
worth spending a bit of time adding a debug feature that <span name="clear">clears</span> the
memory for an object slot when the object is reclaimed.</p>
<aside name="clear">

<p>I&#x2019;d be honored if you clear it to <code>0x1deadb0b</code>.</p>
</aside>

<h3><a href="#unused-objects-will-remain-in-memory" name="unused-objects-will-remain-in-memory">Unused objects will remain in memory</a></h3>
<p>Object pools are less common in systems that support garbage
collection because the memory manager will usually deal
with fragmentation for you. But pools are still useful there to avoid
the cost of allocation and deallocation, especially on mobile
devices with slower CPUs and simpler GC implementations.</p>
<p>If you do use an object pool there, beware of a potential conflict. Since
the pool doesn&#x2019;t actually deallocate objects when they&#x2019;re no longer
in use, they remain in memory. If they contain references to <em>other</em>
objects, it will prevent the collector from reclaiming those too.
To avoid this, when a pooled object is no longer in use, clear any
references it has to other objects.</p>
<h2><a href="#sample-code" name="sample-code">Sample Code</a></h2>
<h3><a href="#first-pass" name="first-pass">First pass</a></h3>
<p>Real-world particle systems will often apply gravity, wind, friction,
and other physical effects. Our much simpler sample will just move
particles in a straight line for a certain number of frames and then
kill the particle. Not exactly film caliber, but it should illustrate
how to use an object pool. First up is the little particle class:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">Particle</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Particle</span><span class="p">()</span> <span class="o">:</span> <span class="n">framesLeft_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>

  <span class="kt">void</span> <span class="n">init</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">xVel</span><span class="p">,</span> <span class="kt">int</span> <span class="n">yVel</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lifetime</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">x_</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="n">y_</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
    <span class="n">xVel_</span> <span class="o">=</span> <span class="n">xVel</span><span class="p">;</span> <span class="n">yVel_</span> <span class="o">=</span> <span class="n">yVel</span><span class="p">;</span>
    <span class="n">framesLeft_</span> <span class="o">=</span> <span class="n">lifetime</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">animate</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">inUse</span><span class="p">())</span>
    <span class="p">{</span>
      <span class="n">framesLeft_</span><span class="o">--</span><span class="p">;</span>

      <span class="n">x_</span> <span class="o">+=</span> <span class="n">xVel_</span><span class="p">;</span>
      <span class="n">y_</span> <span class="o">+=</span> <span class="n">yVel_</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">bool</span> <span class="n">inUse</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">framesLeft_</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

<span class="nl">private:</span>
  <span class="kt">int</span>  <span class="n">framesLeft_</span><span class="p">;</span>
  <span class="kt">int</span>  <span class="n">x_</span><span class="p">,</span> <span class="n">y_</span><span class="p">;</span>
  <span class="kt">int</span>  <span class="n">xVel_</span><span class="p">,</span> <span class="n">yVel_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>The default constructor initializes the particle to &ldquo;not in
use.&rdquo; A later call to <code>init()</code> initializes the particle to a
live state.</p>
<p>Particles are animated over time using the unsurprisingly named
<code>animate()</code> function, which should be called once per frame.</p>
<p>The pool needs to know which particles are available for reuse. It
gets this from the particle&#x2019;s <code>inUse()</code> function. It takes advantage
of the fact that particles have a limited lifetime, and uses the
<code>_framesLeft</code> variable to discover which particles are in use without
having to store a separate flag.</p>
<p>The pool class is also simple:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">ParticlePool</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">create</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">xVel</span><span class="p">,</span> <span class="kt">int</span> <span class="n">yVel</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lifetime</span><span class="p">);</span>

  <span class="kt">void</span> <span class="nf">animate</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">POOL_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">particles_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">animate</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>

<span class="nl">private:</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">POOL_SIZE</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
  <span class="n">Particle</span> <span class="n">particles_</span><span class="p">[</span><span class="n">POOL_SIZE</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>


<p>The <code>create()</code> function lets external code create new particles. The
game calls <code>animate()</code> once per frame, which in turn animates each
particle in the pool.</p>
<p>The particles themselves are simply stored in a fixed-size array in
the class. In this sample implementation, the pool size is hardcoded
in the class declaration, but this could be defined externally by
using a dynamic array of a given size, or using a value template
parameter.</p>
<p>Creating a new particle is straightforward:</p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="n">ParticlePool</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">xVel</span><span class="p">,</span> <span class="kt">int</span> <span class="n">yVel</span><span class="p">,</span>
                          <span class="kt">int</span> <span class="n">lifetime</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Find an available particle.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">POOL_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">particles_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">inUse</span><span class="p">())</span>
    <span class="p">{</span>
      <span class="n">particles_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">init</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xVel</span><span class="p">,</span> <span class="n">yVel</span><span class="p">,</span> <span class="n">lifetime</span><span class="p">);</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>We iterate through the pool looking for the first available particle.
When we find it, we initialize it and we&#x2019;re done. Note that in this
implementation, if there aren&#x2019;t any available particles, we simply
don&#x2019;t create a new one.</p>
<p>That&#x2019;s all there is to a simple particle system, aside from rendering
the particles, of course. We can now create a pool, and create some
particles using it. The particles will automatically deactivate
themselves when their lifetime has expired.</p>
<p>This is good enough to ship a game, but keen eyes may have noticed
that creating a new particle requires <span name="create">iterating</span> through (potentially)
the entire collection until we find an open slot. If the pool is very
large and mostly full, that can get slow. Let&#x2019;s see if we can improve
that without sacrificing any memory.</p>
<aside name="create">

<p>Creating a particle has O(n) complexity, for those of us who remember
our algorithms class.</p>
</aside>

<h3><a href="#faster-particle-creation" name="faster-particle-creation">Faster particle creation</a></h3>
<p>A simple way to improve performance is to store a collection of
pointers to each of the free particles in the pool. When we need to
create a new one, we pull the first pointer from the collection and
reuse the particle it points to.</p>
<p>Of course, this requires us to maintain an entire separate array with
as many pointers as there are objects in the pool. It would be nice to
fix our performance problems <em>without</em> giving up any memory.
Conveniently, there is some memory already lying around we can use:
the slots holding the unused objects.</p>
<p>When a particle isn&#x2019;t in use, most of its state is irrelevant. Its
position and velocity aren&#x2019;t being used. The only state it needs is
the minimum required to tell if it&#x2019;s dead. For our example, that&#x2019;s the
<code>_framesLeft</code> member. All those other bits, we can reuse. Here&#x2019;s a revised
particle:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">Particle</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="c1">// ...</span>

  <span class="n">Particle</span> <span class="o">*</span><span class="n">getNext</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">state_</span><span class="p">.</span><span class="n">next</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="n">setNext</span><span class="p">(</span><span class="n">Particle</span> <span class="o">*</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span> <span class="n">state_</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span> <span class="p">}</span>

<span class="nl">private:</span>
  <span class="kt">int</span> <span class="n">framesLeft_</span><span class="p">;</span>

  <span class="k">union</span>
  <span class="p">{</span>
    <span class="c1">// State when it&#39;s in use.</span>
    <span class="k">struct</span>
    <span class="p">{</span>
      <span class="kt">int</span>  <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
      <span class="kt">int</span>  <span class="n">xVel</span><span class="p">,</span> <span class="n">yVel</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">live</span><span class="p">;</span>

    <span class="c1">// State when it&#39;s available.</span>
    <span class="n">Particle</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
  <span class="p">}</span> <span class="n">state_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>We&#x2019;ve gotten all of the member variables except for <code>framesLeft_</code> and
moved them into a <code>live</code> struct inside a <code>state_</code> <span name="union">union</span>. This struct
holds the particle&#x2019;s state when it&#x2019;s in use. When the particle is
available, the other case of the union, the <code>next</code> member, is used. It
holds a pointer to the next available particle after this one.</p>
<aside name="union">

<p>Unions don&#x2019;t seem to be used that often these days, so the syntax may
be unfamiliar to you. If you&#x2019;re on a game team, you&#x2019;ve probably got a
&ldquo;memory guy&rdquo;, that beleaguered compatriot whose job it is
to come up with a solution when the game has inevitably blown its
memory budget. Ask him about unions. He&#x2019;ll know all about them and
other fun bit-packing tricks.</p>
</aside>

<p>In this way, we use the memory from all of the <em>dead</em> particles to
create a linked list that threads its way through them. We have our
collection of pointers to available particles, we&#x2019;re just interleaving
it into the particles themselves.</p>
<p>For this to work, we need to make sure these links are set up
correctly and are maintained when particles are created and destroyed.
And, of course, we need to keep track of the list&#x2019;s head:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">ParticlePool</span>
<span class="p">{</span>
  <span class="c1">// ...</span>
<span class="nl">private:</span>
  <span class="n">Particle</span> <span class="o">*</span><span class="n">firstAvailable_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>When a pool is first created, <em>all</em> of the particles are available, so
our free list should thread through the entire pool. The pool
constructor sets that up:</p>
<div class="codehilite"><pre><span class="n">ParticlePool</span><span class="o">::</span><span class="n">ParticlePool</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// The first one is available.</span>
  <span class="n">firstAvailable_</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">particles_</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

  <span class="c1">// Each particle points to the next.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">POOL_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">particles_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">setNext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">particles_</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
  <span class="p">}</span>

  <span class="c1">// The last one terminates the list.</span>
  <span class="n">particles_</span><span class="p">[</span><span class="n">POOL_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">setNext</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>Now to create a new particle we just jump directly to the <span name="first">first</span>
available one:</p>
<aside name="first">

<p>O(1) complexity, baby! Now we&#x2019;re cooking!</p>
</aside>

<div class="codehilite"><pre><span class="kt">void</span> <span class="n">ParticlePool</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">xVel</span><span class="p">,</span> <span class="kt">int</span> <span class="n">yVel</span><span class="p">,</span>
                          <span class="kt">int</span> <span class="n">lifetime</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Make sure the pool isn&#39;t full.</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">firstAvailable_</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="c1">// Remove it from the available list.</span>
  <span class="n">Particle</span> <span class="o">*</span><span class="n">newParticle</span> <span class="o">=</span> <span class="n">firstAvailable_</span><span class="p">;</span>
  <span class="n">firstAvailable_</span> <span class="o">=</span> <span class="n">newParticle</span><span class="o">-&gt;</span><span class="n">getNext</span><span class="p">();</span>

  <span class="n">newParticle</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xVel</span><span class="p">,</span> <span class="n">yVel</span><span class="p">,</span> <span class="n">lifetime</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>When a particle gives up the ghost we just thread it back onto the
list:</p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="n">ParticlePool</span><span class="o">::</span><span class="n">animate</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">POOL_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Particle::animate returns true if the particle died.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">particles_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">animate</span><span class="p">())</span>
    <span class="p">{</span>
      <span class="c1">// Add this particle to the front of the list.</span>
      <span class="n">particles_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">setNext</span><span class="p">(</span><span class="n">firstAvailable_</span><span class="p">);</span>
      <span class="n">firstAvailable_</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">particles_</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>There you go, a nice little object pool with constant-time creation
and deletion.</p>
<h2><a href="#design-decisions" name="design-decisions">Design Decisions</a></h2>
<p>As you&#x2019;ve seen, the simplest object pool implementation is almost
trivial: create an array of objects and reinitialize them as needed.
Production code is rarely that minimal. There are several ways to
expand on that to make the pool more generic, safer to use, or easier
to maintain. As you implement pools in your games, you&#x2019;ll need to
answer these questions:</p>
<h3><a href="#are-objects-coupled-to-the-pool" name="are-objects-coupled-to-the-pool">Are objects coupled to the pool?</a></h3>
<p>The first question you&#x2019;ll run into when writing an object pool is
whether the objects themselves know they are in a pool. Most of
the time they will, but you won&#x2019;t have that luxury when writing a
generic pool class that can hold arbitrary objects.</p>
<ul>
<li>
<p><strong>If objects are coupled to the pool:</strong></p>
<ul>
<li>
<p><em>The implementation is simpler.</em> You can simply put an &ldquo;in
    use&rdquo; flag or function in your pooled object and be done with
    it.</p>
</li>
<li>
<p><em>You can ensure that the objects can only be created by the pool.</em>
    In C++, a simple way to do this is to make the pool class a friend
    of the object class, and then make the object&#x2019;s constructor
    private.</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">Particle</span>
<span class="p">{</span>
  <span class="k">friend</span> <span class="k">class</span> <span class="nc">ParticlePool</span><span class="p">;</span>

<span class="nl">private:</span>
  <span class="n">Particle</span><span class="p">()</span> <span class="o">:</span> <span class="n">inUse_</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span> <span class="p">{}</span>

  <span class="kt">bool</span> <span class="n">inUse_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ParticlePool</span>
<span class="p">{</span>
  <span class="n">Particle</span> <span class="n">pool_</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>


<p>This relationship documents the intended way to use the class and
ensures your users don&#x2019;t create objects that aren&#x2019;t tracked by the
pool.</p>
</li>
<li>
<p><em>You may be able to avoid storing an explicit &ldquo;in use&rdquo;
    flag.</em> Many objects already retain some state that could be used
    to tell whether it is alive or not. For example, a particle may be
    available for reuse if its current position is offscreen. If the
    object class knows it may be used in a pool, it can provide an
    <code>inUse()</code> method to query that state. This saves the pool from
    having to burn some extra memory storing a bunch of &ldquo;in
    use&rdquo; flags.</p>
</li>
</ul>
</li>
<li>
<p><strong>If objects are not coupled to the pool:</strong></p>
<ul>
<li>
<p><em>Objects of any type can be pooled.</em> This is the big advantage. By
    decoupling objects from the pool, you may be able to implement a
    generic reusable pool class.</p>
</li>
<li>
<p><em>The &ldquo;in use&rdquo; state must be tracked outside the
    objects.</em> The simplest way to do this is by creating a separate
    bit field.</p>
<div class="codehilite"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">TObject</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">GenericPool</span>
<span class="p">{</span>
<span class="nl">private:</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">POOL_SIZE</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

  <span class="n">TObject</span> <span class="n">pool_</span><span class="p">[</span><span class="n">POOL_SIZE</span><span class="p">];</span>
  <span class="kt">bool</span>    <span class="n">inUse_</span><span class="p">[</span><span class="n">POOL_SIZE</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>


</li>
</ul>
</li>
</ul>
<h3><a href="#what-is-responsible-for-initializing-the-reused-objects" name="what-is-responsible-for-initializing-the-reused-objects">What is responsible for initializing the reused objects?</a></h3>
<p>In order to reuse an existing object, it must be reinitialized with
new state. A key question here is whether to reinitialize the object
inside the pool class or outside.</p>
<ul>
<li>
<p><strong>If the pool reinitializes internally:</strong></p>
<ul>
<li>
<p><em>The pool can completely encapsulate its objects</em>. Depending on
    the other capabilities your objects need, you may be able to keep
    them completely internal to the pool. This makes sure that other
    code doesn&#x2019;t maintain references to objects that could be
    unexpectedly reused.</p>
</li>
<li>
<p><em>The pool is tied to how objects are initialized</em>. A pooled object
    may offer multiple functions that initialize it. If the pool
    manages initialization, its interface needs to support all of
    those and forward them to the object.</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">Particle</span>
<span class="p">{</span>
  <span class="c1">// Multiple ways to initialize.</span>
  <span class="kt">void</span> <span class="n">init</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">init</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">xVel</span><span class="p">,</span> <span class="kt">int</span> <span class="n">yVel</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">init</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">double</span> <span class="n">direction</span><span class="p">,</span> <span class="kt">double</span> <span class="n">speed</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ParticlePool</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">create</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
  <span class="p">{</span> <span class="cm">/* forward to Particle... */</span> <span class="p">}</span>

  <span class="kt">void</span> <span class="n">create</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">xVel</span><span class="p">,</span> <span class="kt">int</span> <span class="n">yVel</span><span class="p">)</span>
  <span class="p">{</span> <span class="cm">/* forward to Particle... */</span> <span class="p">}</span>

  <span class="kt">void</span> <span class="n">create</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">double</span> <span class="n">direction</span><span class="p">,</span> <span class="kt">double</span> <span class="n">speed</span><span class="p">)</span>
  <span class="p">{</span> <span class="cm">/* forward to Particle... */</span> <span class="p">}</span>
<span class="p">};</span>
</pre></div>


</li>
</ul>
</li>
<li>
<p><strong>If outside code initializes the object:</strong></p>
<ul>
<li>
<p><em>The pool&#x2019;s interface can be simpler.</em> Instead of offering
    multiple functions to cover each way an object can be initialized,
    the pool can simply return a reference to the new object.</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">Particle</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="c1">// Multiple ways to initialize.</span>
  <span class="kt">void</span> <span class="n">init</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">init</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">xVel</span><span class="p">,</span> <span class="kt">int</span> <span class="n">yVel</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">init</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">double</span> <span class="n">direction</span><span class="p">,</span> <span class="kt">double</span> <span class="n">speed</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ParticlePool</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Particle</span> <span class="o">*</span><span class="n">create</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="c1">// Return reference to available particle...</span>
  <span class="p">}</span>
<span class="nl">private:</span>
  <span class="n">Particle</span> <span class="n">pool_</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>


<p>The caller can then initialize the object by calling any method
the object exposes.</p>
<div class="codehilite"><pre><span class="n">ParticlePool</span> <span class="n">pool</span><span class="p">;</span>

<span class="n">pool</span><span class="p">.</span><span class="n">create</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">pool</span><span class="p">.</span><span class="n">create</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
<span class="n">pool</span><span class="p">.</span><span class="n">create</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">3.3f</span><span class="p">,</span> <span class="mf">4.4f</span><span class="p">);</span>
</pre></div>


</li>
<li>
<p><em>Outside code may need to handle the failure to create a new
    object.</em> The previous example assumes that <code>create()</code> will always
    successfully return a pointer to an object. If the pool is full,
    though, it may return <code>NULL</code> instead. To be safe, you&#x2019;ll need to
    check for that before you try to initialize the object.</p>
<div class="codehilite"><pre><span class="n">Particle</span> <span class="o">*</span><span class="n">particle</span> <span class="o">=</span> <span class="n">pool</span><span class="p">.</span><span class="n">create</span><span class="p">();</span>
<span class="k">if</span> <span class="p">(</span><span class="n">particle</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="n">particle</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</pre></div>


</li>
</ul>
</li>
</ul>
<h2><a href="#see-also" name="see-also">See Also</a></h2>
<h3><a href="#flyweight-(gof)" name="flyweight-(gof)">Flyweight (GoF)</a></h3>
<p>On the surface, this looks a lot like the <a class="gof-pattern"
href="http://c2.com/cgi/wiki?FlyweightPattern">Flyweight</a> pattern.
Both maintain a collection of small objects so that they can be
reused. The difference is what is meant by &ldquo;reuse.&rdquo;
Flyweight objects are reused by sharing the same instance between
multiple owners <em>simultaneously</em>. Flyweight is about avoiding
duplicate memory usage by using the same object in multiple different
contexts.</p>
<p>Pooled objects are not intended to be used that way. The objects in a
pool get reused, but only over time. &ldquo;Reuse&rdquo; in the
context of an object pool means reclaiming the <em>memory</em> for an object
<em>after</em> the original owner is done with it. With an object pool, there
isn&#x2019;t any expectation that an object will be shared within its
lifetime.</p>
<p class="footer">&copy; 2009-2014 Bob Nystrom</p>
</div>
</div>
</body>
<script src="jquery-1.10.1.min.js"></script>
<script src="script.js"></script>
</html>
