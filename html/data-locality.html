<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />

<title>Data Locality &middot; Optimization Patterns &middot; Game Programming Patterns</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />
<link href="https://fonts.googleapis.com/css?family=Merriweather:400,400italic,700,700italic|Source+Code+Pro|Source+Sans+Pro:200,300,400,600,400italic,600italic|Rock+Salt" rel="stylesheet" type="text/css">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-1', 'gameprogrammingpatterns.com');
  ga('send', 'pageview');
</script>
<script src="jquery-3.6.0.min.js"></script>
<script src="script.js"></script>
</head>
<body id="top">
<div class="page sidebar">
<div class="content">
<nav class="top">
  <span class="prev">&larr; <a href="optimization-patterns.html">Previous Chapter</a></span>
  <span class="next"><a href="dirty-flag.html">Next Chapter</a> &rarr;</span>
  <span class="toc">&equiv; <a href="/">The Book</a></span>
</nav>
<h1>Data Locality</h1>
<h1 class="book"><a href="/">Game Programming Patterns</a><span class="section"><a href="optimization-patterns.html">Optimization Patterns</a></span></h1>
<h2><a href="#intent" name="intent">Intent</a></h2>
<p><em>Accelerate memory access by arranging data to take advantage of CPU caching.</em></p>
<h2><a href="#motivation" name="motivation">Motivation</a></h2>
<p>We&#8217;ve been lied to. They keep showing us charts where CPU speed goes up and up
every year as if Moore&#8217;s Law isn&#8217;t just a historical observation but some kind
of divine right. Without lifting a finger, we software folks watch our programs
magically accelerate just by virtue of new hardware.</p>
<p>Chips <em>have</em> been getting faster (though even that&#8217;s plateauing now), but the
hardware heads failed to mention something. Sure, we can <em>process</em> data faster
than ever, but we can&#8217;t <em>get</em> that data faster.</p>
<p><span name="legend"></span></p>
<p><img src="images/data-locality-chart.png" alt="A chart showing processor and RAM speed from 1980 to 2010. Processor speed increases quickly, but RAM speed lags behind." /></p>
<aside name="legend">
<p>Processor and RAM speed relative to their respective speeds in 1980. As you can
see, CPUs have grown in leaps and bounds, but RAM access is lagging far behind.</p>
<p>Data for this is from <em>Computer Architecture: A Quantitative Approach</em>
by John L. Hennessy, David A. Patterson, Andrea C. Arpaci-Dusseau by way of Tony
Albrecht&#8217;s &#8220;<a href="http://seven-degrees-of-freedom.blogspot.com/2009/12/pitfalls-of-object-oriented-programming.html">Pitfalls of Object-Oriented Programming</a>&rdquo;.</p>
</aside>
<p>For your super-fast CPU to blow through a ream of calculations, it actually has
to get the data out of main memory and into registers. As you can see, RAM hasn&#8217;t
been keeping up with increasing CPU speeds. Not even close.</p>
<p>With today&#8217;s hardware, it can take <em>hundreds</em> of cycles to fetch a byte of data
from <span name="ram">RAM</span>. If most instructions need data, and it takes
hundreds of cycles to get it, how is it that our CPUs aren&#8217;t sitting idle 99%
of the time waiting for data?</p>
<p>Actually, they <em>are</em> stuck waiting on memory an astonishingly large fraction of
time these days, but it&#8217;s not as bad as it could be. To explain how, let&#8217;s take
a trip to the Land of Overly Long Analogies&#8230;</p>
<aside name="ram">
<p>It&#8217;s called &#8220;random access memory&#8221; because, unlike disc drives, you can
theoretically access any piece of it as quick as any other. You don&#8217;t have
to worry about reading things consecutively like you do a disc.</p>
<p>Or, at least, you <em>didn&#8217;t</em>. As we&#8217;ll see, RAM isn&#8217;t so random access anymore.</p>
</aside>
<h3><a href="#a-data-warehouse" name="a-data-warehouse">A data warehouse</a></h3>
<p>Imagine you&#8217;re an accountant in a tiny little office. Your job is to request a
box of papers and then do some <span name="accountant">accountant</span>-y stuff
with them&#8202;&mdash;&#8202;add up a bunch of numbers or something. You must do this for
specific labeled boxes according to some arcane logic that only makes sense to
other accountants.</p>
<aside name="accountant">
<p>I probably shouldn&#8217;t have used a job I know absolutely nothing about in this
analogy.</p>
</aside>
<p>Thanks to a mixture of hard work, natural aptitude, and stimulants, you can
finish an entire box in, say, a minute. There&#8217;s a little problem, though. All of
those boxes are stored in a warehouse in a separate building. To get a box, you
have to ask the warehouse guy to bring it to you. He goes and gets a forklift
and drives around the aisles until he finds the box you want.</p>
<p>It takes him, seriously, an entire day to do this. Unlike you, he&#8217;s not getting
employee of the month any time soon. This means that no matter how fast you are,
you only get one box a day. The rest of the time, you just sit there and
question the life decisions that led to this soul-sucking job.</p>
<p>One day, a group of industrial designers shows up. Their job is to improve the
efficiency of operations&#8202;&mdash;&#8202;things like making assembly lines go faster. After
watching you work for a few days, they notice a few things:</p>
<ul>
<li>
<p>Pretty often, when you&#8217;re done with one box, the next box you request is
    right <span name="next">next</span> to it on the same shelf in the
    warehouse.</p>
</li>
<li>
<p>Using a forklift to carry a single box of papers is pretty dumb.</p>
</li>
<li>
<p>There&#8217;s actually a little bit of spare room in the corner of your office.</p>
</li>
</ul>
<aside name="next">
<p>The technical term for using something near the thing you just used is <em>locality
of reference</em>.</p>
</aside>
<p>They come up with a clever fix. Whenever you request a box from the warehouse
guy, he&#8217;ll grab an entire pallet of them. He gets the box you want and then some
more boxes that are next to it. He doesn&#8217;t know if you want those (and, given
his work ethic, clearly doesn&#8217;t care); he simply takes as many as he can fit on
the pallet.</p>
<p>He loads the whole pallet and brings it to you. Disregarding concerns for
workplace safety, he drives the forklift right in and drops the pallet in the
corner of your office.</p>
<p>When you need a new box, now, the first thing you do is see if it&#8217;s already on
the pallet in your office. If it is, great! It only takes you a second to grab
it and get back to crunching numbers. If a pallet holds fifty boxes and you
got lucky and <em>all</em> of the boxes you need happen to be on it, you can churn
through fifty times more work than you could before.</p>
<p>But if you need a box that&#8217;s <em>not</em> on the pallet, you&#8217;re back to square one.
Since you can only fit one pallet in your office, your warehouse friend will
have to take that one back and then bring you an entirely new one.</p>
<h3><a href="#a-pallet-for-your-cpu" name="a-pallet-for-your-cpu">A pallet for your CPU</a></h3>
<p>Strangely enough, this is similar to how CPUs in modern computers work. In case
it isn&#8217;t obvious, you play the role of the CPU. Your desk is the CPU&#8217;s
registers, and the box of papers is the data you can fit in them. The warehouse
is your machine&#8217;s RAM, and that annoying warehouse guy is the bus that pulls
data from main memory into registers.</p>
<p>If I were writing this chapter thirty years ago, the analogy would stop there.
But as chips got faster and RAM, well, <em>didn&#8217;t</em>, hardware engineers started
looking for solutions. What they came up with was <em>CPU caching</em>.</p>
<p>Modern computers have a <span name="caches">little chunk</span> of memory right
inside the chip. The CPU can pull data from this much faster than it can from
main memory. It&#8217;s small because it has to fit in the chip and because the faster
type of memory it uses (static RAM or &#8220;SRAM&#8221;) is way more expensive.</p>
<aside name="caches">
<p>Modern hardware has multiple levels of caching, which is what they mean
when you hear &#8220;L1&#8221;, &#8220;L2&#8221;, &#8220;L3&#8221;, etc. Each level is larger but slower than the
previous. For this chapter, we won&#8217;t worry about the fact that memory is
actually a <a href="http://en.wikipedia.org/wiki/Memory_hierarchy">hierarchy</a>, but it&#8217;s
important to know.</p>
</aside>
<p>This little chunk of memory is called a <em>cache</em> (in particular, the chunk on the
chip is your <em>L1 cache</em>), and in my belabored analogy, its part was played by the
pallet of boxes. Whenever your chip needs a byte of data from RAM, it
automatically grabs a whole chunk of contiguous memory&#8202;&mdash;&#8202;usually around 64 to
128 bytes&#8202;&mdash;&#8202;and puts it in the cache. This dollop of memory is called a <em>cache
line</em>.</p>
<p><img src="images/data-locality-cache-line.png" alt="A cache line showing the one byte requested along with the adjacent bytes that also get loaded into the cache." /></p>
<p>If the <span name="pallet">next byte</span> of data you need happens to be in
that chunk, the CPU reads it straight from the cache, which is <em>much</em> faster
than hitting RAM. Successfully finding a piece of data in the cache is called a
<em>cache hit</em>. If it can&#8217;t find it in there and has to go to main memory, that&#8217;s a
<em>cache miss</em>.</p>
<aside name="pallet">
<p>I glossed over (at least) one detail in the analogy. In your office, there was
only room for one pallet, or one cache line. A real cache contains a number of
cache lines. The details about how those work is out of scope here, but search
for &#8220;cache associativity&#8221; to feed your brain.</p>
</aside>
<p>When a cache miss occurs, the CPU <em>stalls</em>&#8202;&mdash;&#8202;it can&#8217;t process the next
instruction because it needs data. It sits there, bored out of its mind for a
few hundred cycles until the fetch completes. Our mission is to avoid that.
Imagine you&#8217;re trying to optimize some performance-critical piece of game code
and it looks like this:</p>
<div class="codehilite"><pre><span></span><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_THINGS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">sleepFor500Cycles</span><span class="p">();</span>
  <span class="n">things</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">doStuff</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>

<p>What&#8217;s the first change you&#8217;re going to make to that code? Right. Take out that
pointless, expensive function call. That call is equivalent to the performance
cost of a cache miss. Every time you bounce to main memory, it&#8217;s like you put a
delay in your code.</p>
<h3><a href="#wait,-data-is-performance" name="wait,-data-is-performance">Wait, data is performance?</a></h3>
<p>When I started working on this chapter, I spent some time putting together
little game-like programs that would trigger best case and worst case cache
usage. I wanted benchmarks that would thrash the cache so I could see first-hand
how much bloodshed it causes.</p>
<p>When I got some stuff working, I was surprised. I knew it was a big deal, but
there&#8217;s nothing quite like seeing it with your own eyes. <span name="ymmv">I
wrote two programs</span> that did the <em>exact same</em> computation. The only
difference was how many cache misses they caused. The slow one was <em>fifty times</em>
slower than the other.</p>
<aside name="ymmv">
<p>There are a lot of caveats here. In particular, different computers have different
cache setups, so my machine may be different from yours, and dedicated game
consoles are very different from PCs, which are quite different from mobile
devices.</p>
<p>Your mileage will vary.</p>
</aside>
<p>This was a real eye-opener to me. I&#8217;m used to thinking of performance being an
aspect of <em>code</em>, not <em>data</em>. A byte isn&#8217;t slow or fast, it&#8217;s just some static
thing sitting there. But because of caching, <em>the way you organize data
directly impacts performance</em>.</p>
<p>The challenge now is to wrap that up into something that fits into a chapter
here. Optimization for cache usage is a huge topic. I haven&#8217;t even touched on
<em>instruction caching</em>. Remember, code is in memory too and has to be loaded onto
the CPU before it can be executed. Someone more versed on the subject could
write an entire <span name="book">book</span> on it.</p>
<aside name="book">
<p>In fact, someone <em>did</em> write a book on it: <a href="http://www.dataorienteddesign.com/dodmain/"><em>Data-Oriented
Design</em></a>, by Richard Fabian.</p>
</aside>
<p>Since you&#8217;re already reading <em>this</em> book right now, though, I have a few basic
techniques that will get you started along the path of thinking about how data
structures impact your performance.</p>
<p>It all boils down to something pretty simple: whenever the chip reads some
memory, it gets a whole cache line. The more you can use stuff in that <span
name="line">cache line, the faster you go</span>. So the goal then is to
<em>organize your data structures so that the things you&#8217;re processing are next to
each other in memory</em>.</p>
<aside name="line">
<p>There&#8217;s a key assumption here, though: one thread. If you are modifying nearby
data on multiple threads, it&#8217;s faster to have it on <em>different</em> cache lines. If
two threads try to tweak data on the same cache line, both cores have to do some
costly synchronization of their caches.</p>
</aside>
<p>In other words, if your code is crunching on <code>Thing</code>, then <code>Another</code>, then
<code>Also</code>, you want them laid out in memory like this:</p>
<p><img src="images/data-locality-things.png" alt="Thing, Another, and Also laid out directly next to each other in order in memory." /></p>
<p>Note, these aren&#8217;t <em>pointers</em> to <code>Thing</code>, <code>Another</code>, and <code>Also</code>. This is the
actual data for them, in place, lined up one after the other. As soon as the CPU
reads in <code>Thing</code>, it will start to get <code>Another</code> and <code>Also</code> too (depending on
how big they are and how big a cache line is). When you start working on them
next, they&#8217;ll already be cached. Your chip is happy, and you&#8217;re happy.</p>
<h2><a href="#the-pattern" name="the-pattern">The Pattern</a></h2>
<p>Modern CPUs have <strong>caches to speed up memory access</strong>. These can access memory
<strong>adjacent to recently accessed memory much quicker</strong>. Take advantage of that to
improve performance by <strong>increasing data locality</strong>&#8202;&mdash;&#8202;keeping data in
<strong>contiguous memory in the order that you process it</strong>.</p>
<h2><a href="#when-to-use-it" name="when-to-use-it">When to Use It</a></h2>
<p>Like most optimizations, the first guideline for using the Data Locality pattern is <em>when you have a
performance problem.</em> Don&#8217;t waste time applying this to some infrequently
executed corner of your codebase. Optimizing code that doesn&#8217;t need it just
makes your life harder since the result is almost always more complex and less
flexible.</p>
<p>With this pattern specifically, you&#8217;ll also want to be sure your performance
problems <em>are caused by cache misses</em>. If your code is slow for other reasons,
this won&#8217;t help.</p>
<p>The cheap way to profile is to manually add a bit of instrumentation that checks
how much time has elapsed between two points in the code, hopefully using a
precise timer. To catch poor cache usage, you&#8217;ll want something a little more
sophisticated. You really want to see how many cache misses are occurring and
where.</p>
<p>Fortunately, there are <span name="cachegrind">profilers</span> out there that
report this. It&#8217;s worth spending the time to get one of these working and make
sure you understand the (surprisingly complex) numbers it throws at you before
you do major surgery on your data structures.</p>
<aside name="cachegrind">
<p>Unfortunately, most of those tools aren&#8217;t cheap. If you&#8217;re on a console dev
team, you probably already have licenses for them.</p>
<p>If not, an excellent free option is
<a href="http://valgrind.org/docs/manual/cg-manual.html">Cachegrind</a>. It runs your
program on top of a simulated CPU and cache hierarchy and then reports all of
the cache interactions.</p>
</aside>
<p>That being said, cache misses <em>will</em> affect the performance of your game. While
you shouldn&#8217;t spend a ton of time pre-emptively optimizing for cache usage, do
think about how cache-friendly your data structures are throughout the design
process.</p>
<h2><a href="#keep-in-mind" name="keep-in-mind">Keep in Mind</a></h2>
<p>One of the hallmarks of software architecture is <em>abstraction</em>. A large chunk of
this book is about patterns to decouple pieces of code from each other so that
they can be changed more easily. In object-oriented languages, this almost
always means interfaces.</p>
<p>In C++, using interfaces implies accessing objects through <span
name="virtual">pointers or references</span>. But going through a pointer means
hopping across memory, which leads to the cache misses this pattern works to
avoid.</p>
<aside name="virtual">
<p>The other half of interfaces is <em>virtual method calls</em>. Those require the CPU to
look up an object&#8217;s vtable and then find the pointer to the actual method to
call there. So, again, you&#8217;re chasing pointers, which can cause cache misses.</p>
</aside>
<p>In order to please this pattern, you will have to sacrifice some of your
precious abstractions. The more you design your program around data locality,
the more you will have to give up inheritance, interfaces, and the benefits
those tools can provide. There&#8217;s no silver bullet here, only challenging
trade-offs. That&#8217;s what makes it fun!</p>
<h2><a href="#sample-code" name="sample-code">Sample Code</a></h2>
<p>If you really go down the rathole of optimizing for data locality, you&#8217;ll
discover countless ways to slice and dice your data structures into pieces your
CPU can most easily digest. To get you started, I&#8217;ll show an example for each of
a few of the most common ways to organize your data. We&#8217;ll cover them in the
context of some specific part of a game engine, but (as with other patterns),
keep in mind that the general technique can be applied anywhere it fits.</p>
<h3><a href="#contiguous-arrays" name="contiguous-arrays">Contiguous arrays</a></h3>
<p>Let&#8217;s start with a <a href="game-loop.html" class="pattern">game loop</a> that
processes a bunch of game entities. Those entities are decomposed into different
domains&#8202;&mdash;&#8202;AI, physics, and rendering&#8202;&mdash;&#8202;using the <a href="component.html"
class="pattern">Component</a> pattern. Here&#8217;s the <code>GameEntity</code> class:</p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">GameEntity</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">GameEntity</span><span class="p">(</span><span class="n">AIComponent</span><span class="o">*</span> <span class="n">ai</span><span class="p">,</span>
             <span class="n">PhysicsComponent</span><span class="o">*</span> <span class="n">physics</span><span class="p">,</span>
             <span class="n">RenderComponent</span><span class="o">*</span> <span class="n">render</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">ai_</span><span class="p">(</span><span class="n">ai</span><span class="p">),</span> <span class="n">physics_</span><span class="p">(</span><span class="n">physics</span><span class="p">),</span> <span class="n">render_</span><span class="p">(</span><span class="n">render</span><span class="p">)</span>
  <span class="p">{}</span>

  <span class="n">AIComponent</span><span class="o">*</span> <span class="n">ai</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ai_</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">PhysicsComponent</span><span class="o">*</span> <span class="n">physics</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">physics_</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">RenderComponent</span><span class="o">*</span> <span class="n">render</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">render_</span><span class="p">;</span> <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="n">AIComponent</span><span class="o">*</span> <span class="n">ai_</span><span class="p">;</span>
  <span class="n">PhysicsComponent</span><span class="o">*</span> <span class="n">physics_</span><span class="p">;</span>
  <span class="n">RenderComponent</span><span class="o">*</span> <span class="n">render_</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>Each component has a relatively small amount of state, maybe little more than a
few vectors or a matrix, and then a method to <span name="update">update</span>
it. The details aren&#8217;t important here, but imagine something roughly along the
lines of:</p>
<aside name="update">
<p>As the name implies, these are examples of the <a href="update-method.html"
class="pattern">Update Method</a> pattern. Even <code>render()</code> is this pattern, just
by another name.</p>
</aside>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">AIComponent</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">update</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* Work with and modify state... */</span> <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="c1">// Goals, mood, etc. ...</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">PhysicsComponent</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">update</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* Work with and modify state... */</span> <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="c1">// Rigid body, velocity, mass, etc. ...</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">RenderComponent</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">render</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* Work with and modify state... */</span> <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="c1">// Mesh, textures, shaders, etc. ...</span>
<span class="p">};</span>
</code></pre></div>

<p>The game maintains a big array of pointers to all of the entities in the world.
Each spin of the game loop, we need to run the following:</p>
<ol>
<li>
<p>Update the AI components for all of the entities.</p>
</li>
<li>
<p>Update the physics components for them.</p>
</li>
<li>
<p>Render them using their render components.</p>
</li>
</ol>
<p>Lots of game engines implement that like so:</p>
<div class="codehilite"><pre><span></span><code><span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">gameOver</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Process AI.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numEntities</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">entities</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ai</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// Update physics.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numEntities</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">entities</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">physics</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// Draw to screen.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numEntities</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">entities</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">render</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">render</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// Other game loop machinery for timing...</span>
<span class="p">}</span>
</code></pre></div>

<p>Before you ever heard of a CPU cache, this looked totally innocuous. But by now,
you&#8217;ve got an inkling that something isn&#8217;t right here. This code isn&#8217;t just
thrashing the cache, it&#8217;s taking it around back and beating it to a pulp. Watch
what it&#8217;s doing:</p>
<ol>
<li>
<p>The array of game entities is storing <em>pointers</em> to them, so for each element in the
    array, we have to traverse that pointer. That&#8217;s a cache miss.</p>
</li>
<li>
<p>Then the game entity has a pointer to the component. Another cache miss.</p>
</li>
<li>
<p>Then we update the component.</p>
</li>
<li>
<p>Now we go back to step one for <em>every component of every entity in the
    game</em>.</p>
</li>
</ol>
<p>The scary part is that we have no idea how these objects are laid out in memory.
We&#8217;re completely at the mercy of the memory manager. As entities get allocated
and freed over time, the heap is likely to become increasingly randomly
organized.</p>
<p><span name="lines"></span></p>
<p><img src="images/data-locality-pointer-chasing.png" alt="A tangled mess of objects strewn randomly through memory with pointers wiring them all together." /></p>
<aside name="lines">
<p>Every frame, the game loop has to follow all of those arrows to get to the data
it cares about.</p>
</aside>
<p>If our goal was to take a whirlwind tour around the game&#8217;s address space like
some &#8220;256MB of RAM in Four Nights!&#8221; cheap vacation package, this would be a
fantastic deal. But our goal is to run the game quickly, and <span
name="chase">traipsing</span> all over main memory is <em>not</em> the way to do that.
Remember that <code>sleepFor500Cycles()</code> function? Well this code is effectively
calling that <em>all the time</em>.</p>
<aside name="chase">
<p>The term for wasting a bunch of time traversing pointers is &#8220;pointer chasing&#8221;,
which it turns out is nowhere near as fun as it sounds.</p>
</aside>
<p>Let&#8217;s do something better. Our first observation is that the only reason we
follow a pointer to get to the game entity is so we can immediately follow
<em>another</em> pointer to get to a component. <code>GameEntity</code> itself has no interesting
state and no useful methods. The <em>components</em> are what the game loop cares
about.</p>
<p>Instead of a giant constellation of game entities and components scattered
across the inky darkness of address space, we&#8217;re going to get back down to
Earth. We&#8217;ll have a big array for each type of component: a flat array of AI
components, another for physics, and another for rendering.</p>
<p>Like this:</p>
<p><span name="long-name"></span></p>
<div class="codehilite"><pre><span></span><code><span class="n">AIComponent</span><span class="o">*</span> <span class="n">aiComponents</span> <span class="o">=</span>
    <span class="k">new</span> <span class="n">AIComponent</span><span class="p">[</span><span class="n">MAX_ENTITIES</span><span class="p">];</span>
<span class="n">PhysicsComponent</span><span class="o">*</span> <span class="n">physicsComponents</span> <span class="o">=</span>
    <span class="k">new</span> <span class="n">PhysicsComponent</span><span class="p">[</span><span class="n">MAX_ENTITIES</span><span class="p">];</span>
<span class="n">RenderComponent</span><span class="o">*</span> <span class="n">renderComponents</span> <span class="o">=</span>
    <span class="k">new</span> <span class="n">RenderComponent</span><span class="p">[</span><span class="n">MAX_ENTITIES</span><span class="p">];</span>
</code></pre></div>

<aside name="long-name">
<p>My least favorite part about using components is how long the word &#8220;component&#8221;
is.</p>
</aside>
<p>Let me stress that these are arrays of <em>components</em> and not <em>pointers to
components</em>. The data is all there, one byte after the other. The game loop can
then walk these directly:</p>
<p><span name="arrow"></span></p>
<div class="codehilite"><pre><span></span><code><span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">gameOver</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Process AI.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numEntities</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">aiComponents</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">update</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// Update physics.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numEntities</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">physicsComponents</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">update</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// Draw to screen.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numEntities</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">renderComponents</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">render</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// Other game loop machinery for timing...</span>
<span class="p">}</span>
</code></pre></div>

<aside name="arrow">
<p>One hint that we&#8217;re doing better here is how few <code>-&gt;</code> operators there are in the
new code. If you want to improve data locality, look for indirection operators
you can get rid of.</p>
</aside>
<p>We&#8217;ve ditched all of that pointer chasing. Instead of skipping around in memory,
we&#8217;re doing a straight crawl through three contiguous arrays.</p>
<p><img src="images/data-locality-component-arrays.png" alt="An array for each of three different kinds of components. Each array neatly packs its components together." /></p>
<p>This pumps a solid stream of bytes right into the hungry maw of the CPU. In my
testing, this change made the update loop <em>fifty times</em> faster than the previous
version.</p>
<p>Interestingly, we haven&#8217;t lost much encapsulation here. Sure, the game loop is
updating the components directly instead of going through the game entities, but
it was doing that before to ensure they were processed in the right order. Even
so, each component itself is still nicely encapsulated. It owns its own data and
methods. We simply changed the way it&#8217;s used.</p>
<p>This doesn&#8217;t mean we need to get rid of <code>GameEntity</code> either. We can leave it as it
is with pointers to its components. They&#8217;ll just point into those
arrays. This is still useful for other parts of the game where you want to pass
around a conceptual &#8220;game entity&#8221; and everything that goes with it. The
important part is that the performance-critical game loop sidesteps that and
goes straight to the data.</p>
<h3><a href="#packed-data" name="packed-data">Packed data</a></h3>
<p>Say we&#8217;re doing a particle system. Following the advice of the previous section,
we&#8217;ve got all of our particles in a nice big contiguous array. Let&#8217;s wrap it in
a little <span name="pool">manager class</span> too:</p>
<aside name="pool">
<p>The <code>ParticleSystem</code> class is an example of an <a href="object-pool.html"
class="pattern">Object Pool</a> custom built for a single type of object.</p>
</aside>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">Particle</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">update</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* Gravity, etc. ... */</span> <span class="p">}</span>
  <span class="c1">// Position, velocity, etc. ...</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ParticleSystem</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">ParticleSystem</span><span class="p">()</span>
  <span class="o">:</span> <span class="n">numParticles_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
  <span class="p">{}</span>

  <span class="kt">void</span> <span class="n">update</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">MAX_PARTICLES</span> <span class="o">=</span> <span class="mi">100000</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">numParticles_</span><span class="p">;</span>
  <span class="n">Particle</span> <span class="n">particles_</span><span class="p">[</span><span class="n">MAX_PARTICLES</span><span class="p">];</span>
<span class="p">};</span>
</code></pre></div>

<p>A rudimentary update method for the system just looks like this:</p>
<div class="codehilite"><pre><span></span><code><span class="kt">void</span> <span class="nf">ParticleSystem::update</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numParticles_</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">particles_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">update</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>But it turns out that we don&#8217;t actually need to process <em>all</em> of the particles
all the time. The particle system has a fixed-size pool of objects, but they
aren&#8217;t usually all actively twinkling across the screen. The easy answer is
something like this:</p>
<div class="codehilite"><pre><span></span><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numParticles_</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">particles_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">isActive</span><span class="p">())</span>
  <span class="p">{</span>
    <span class="n">particles_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">update</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>We give <code>Particle</code> a flag to track whether its in use or not. In the update
loop, we <span name="branch">check</span> that for each particle. That loads the
flag into the cache along with all of that particle&#8217;s other data. If the
particle <em>isn&#8217;t</em> active, then we skip over it to the next one. The rest
of the particle&#8217;s data that we loaded into the cache is a waste.</p>
<p>The fewer active particles there are, the more we&#8217;re skipping across memory. The
more we do that, the more cache misses there are between actually doing useful
work updating active particles. If the array is large and has <em>lots</em> of inactive
particles in it, we&#8217;re back to thrashing the cache again.</p>
<p>Having objects in a contiguous array doesn&#8217;t solve much if the objects we&#8217;re
actually processing aren&#8217;t contiguous in it. If it&#8217;s littered with inactive
objects we have to dance around, we&#8217;re right back to the original problem.</p>
<aside name="branch">
<p>Savvy low-level coders can see another problem here. Doing an <code>if</code> check for
every particle can cause a <em>branch misprediction</em> and a <em>pipeline stall</em>. In
modern CPUs, a single &#8220;instruction&#8221; actually takes several clock cycles. To keep
the CPU busy, instructions are <em>pipelined</em> so that the subsequent instructions
start processing before the first one finishes.</p>
<p>To do that, the CPU has to guess which instructions it will be executing next.
In straight line code, that&#8217;s easy, but with control flow, it&#8217;s harder. While
it&#8217;s executing the instructions for that <code>if</code>, does it guess that the particle
is active and start executing the code for the <code>update()</code> call, or does it guess
that it isn&#8217;t?</p>
<p>To answer that, the chip does <em>branch prediction</em>&#8202;&mdash;&#8202;it sees which branches your
code previously took and guesses that it will do that again. But when the loop
is constantly toggling between particles that are and aren&#8217;t active, that
prediction fails.</p>
<p>When it does, the CPU has to ditch the instructions it had started speculatively
processing (a <em>pipeline flush</em>) and start over. The performance impact of this
varies widely by machine, but this is why you sometimes see developers avoid
flow control in hot code.</p>
</aside>
<p>Given the title of this section, you can probably guess the answer. Instead of
<em>checking</em> the active flag, we&#8217;ll <em>sort</em> by it. We&#8217;ll keep all of the active
particles in the front of the list. If we know all of those particles are
active, we don&#8217;t have to check the flag at all.</p>
<p>We can also easily keep track of how many active particles there are. With this,
our update loop turns into this thing of beauty:</p>
<div class="codehilite"><pre><span></span><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numActive_</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">particles</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">update</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>

<p>Now we aren&#8217;t skipping over <em>any</em> data. Every byte that gets sucked into the
cache is a piece of an active particle that we actually need to process.</p>
<p>Of course, I&#8217;m not saying you should quicksort the entire collection of
particles every frame. That would more than eliminate the gains here. What we
want to do is <em>keep</em> the array sorted.</p>
<p>Assuming the array is already sorted&#8202;&mdash;&#8202;and it is at first when all particles
are inactive&#8202;&mdash;&#8202;the only time it can become <em>un</em>sorted is when a particle has
been activated or deactivated. We can handle those two cases pretty easily. When
a particle gets activated, we move it up to the end of the active particles by
swapping it with the first <em>in</em>active one:</p>
<div class="codehilite"><pre><span></span><code><span class="kt">void</span> <span class="nf">ParticleSystem::activateParticle</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Shouldn&#39;t already be active!</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">numActive_</span><span class="p">);</span>

  <span class="c1">// Swap it with the first inactive particle</span>
  <span class="c1">// right after the active ones.</span>
  <span class="n">Particle</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">particles_</span><span class="p">[</span><span class="n">numActive_</span><span class="p">];</span>
  <span class="n">particles_</span><span class="p">[</span><span class="n">numActive_</span><span class="p">]</span> <span class="o">=</span> <span class="n">particles_</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
  <span class="n">particles_</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>

  <span class="c1">// Now there&#39;s one more.</span>
  <span class="n">numActive_</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>To deactivate a particle, we just do the opposite:</p>
<div class="codehilite"><pre><span></span><code><span class="kt">void</span> <span class="nf">ParticleSystem::deactivateParticle</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Shouldn&#39;t already be inactive!</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">numActive_</span><span class="p">);</span>

  <span class="c1">// There&#39;s one fewer.</span>
  <span class="n">numActive_</span><span class="o">--</span><span class="p">;</span>

  <span class="c1">// Swap it with the last active particle</span>
  <span class="c1">// right before the inactive ones.</span>
  <span class="n">Particle</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">particles_</span><span class="p">[</span><span class="n">numActive_</span><span class="p">];</span>
  <span class="n">particles_</span><span class="p">[</span><span class="n">numActive_</span><span class="p">]</span> <span class="o">=</span> <span class="n">particles_</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
  <span class="n">particles_</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>Lots of programmers (myself included) have developed allergies to moving things
around in memory. Schlepping a bunch of bytes around <em>feels</em> heavyweight
compared to assigning a pointer. But when you add in the cost of
<em>traversing</em> that pointer, it turns out that our intuition is sometimes wrong.
In <span name="profile">some cases</span>, it&#8217;s cheaper to push things around in
memory if it helps you keep the cache full.</p>
<aside name="profile">
<p>This is your friendly reminder to <em>profile</em> when making these kinds of
decisions.</p>
</aside>
<p>There&#8217;s a neat consequence of keeping the particles <em>sorted</em> by their active
state&#8202;&mdash;&#8202;we don&#8217;t need to store an active flag in each particle at all. It can be
inferred by its position in the array and the <code>numActive_</code> counter. This makes
our particle objects smaller, which means we can pack more in our cache lines,
and that makes them even faster.</p>
<p>It&#8217;s not all rosy, though. As you can see from the API, we&#8217;ve lost a bit of
object orientation here. The <code>Particle</code> class no longer controls its own active
state. You can&#8217;t call some <code>activate()</code> method on it since it doesn&#8217;t know
its index. Instead, any code that wants to activate particles needs access to
the particle <em>system</em>.</p>
<p>In this case, I&#8217;m OK with <code>ParticleSystem</code> and <code>Particle</code> being tightly tied
like this. I think of them as a single <em>concept</em> spread across two physical
<em>classes</em>. It just means accepting the idea that particles are <em>only</em> meaningful
in the context of some particle system. Also, in this case it&#8217;s likely to be the
particle system that will be spawning and killing particles anyway.</p>
<h3><a href="#hotcold-splitting" name="hotcold-splitting">Hot/cold splitting</a></h3>
<p>OK, this is the last example of a simple technique for making your cache
happier. Say we&#8217;ve got an AI component for some game entity. It has some state
in it&#8202;&mdash;&#8202;the animation it&#8217;s currently playing, a goal position it&#8217;s heading
towards, energy level, etc.&#8202;&mdash;&#8202;stuff it checks and tweaks every single frame.
Something like:</p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">AIComponent</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">update</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="n">Animation</span><span class="o">*</span> <span class="n">animation_</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">energy_</span><span class="p">;</span>
  <span class="n">Vector</span> <span class="n">goalPos_</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>But it also has some state for rarer eventualities. It stores some data
describing what loot it drops when it has an unfortunate encounter with the
noisy end of a shotgun. That drop data is only used once in the entity&#8217;s
lifetime, right at its bitter end:</p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">AIComponent</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">update</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="c1">// Previous fields...</span>
  <span class="n">LootType</span> <span class="n">drop_</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">minDrops_</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">maxDrops_</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">chanceOfDrop_</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>Assuming we followed the earlier patterns, when we update these AI components,
we walk through a nice packed, contiguous array of data. But that data includes
all of the loot drop information. That makes each component bigger, which
reduces the number of components we can fit in a cache line. We get more cache misses
because the total memory we walk over is larger. The loot data gets pulled into
the cache for every component in every frame, even though we aren&#8217;t even touching
it.</p>
<p>The solution for this is called &#8220;hot/cold splitting&#8221;. The idea is to break our
data structure into two separate pieces. The first holds the &#8220;hot&#8221; data, the
state we need to touch every frame. The other piece is the &#8220;cold&#8221; data,
everything else that gets used less frequently.</p>
<p>The hot piece is the <em>main</em> AI component. It&#8217;s the one we need to use the most,
so we don&#8217;t want to chase a pointer to find it. The cold component can be off to
the side, but we still need to get to it, so we give the hot component a pointer
to it, like so:</p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">AIComponent</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="c1">// Methods...</span>
<span class="k">private</span><span class="o">:</span>
  <span class="n">Animation</span><span class="o">*</span> <span class="n">animation_</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">energy_</span><span class="p">;</span>
  <span class="n">Vector</span> <span class="n">goalPos_</span><span class="p">;</span>

  <span class="n">LootDrop</span><span class="o">*</span> <span class="n">loot_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">LootDrop</span>
<span class="p">{</span>
  <span class="k">friend</span> <span class="k">class</span> <span class="nc">AIComponent</span><span class="p">;</span>
  <span class="n">LootType</span> <span class="n">drop_</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">minDrops_</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">maxDrops_</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">chanceOfDrop_</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>Now when we&#8217;re walking the AI components every frame, the only data that gets
loaded into the cache is stuff we are actually processing (with the <span
name="parallel">exception</span> of that one little pointer to the cold data).</p>
<aside name="parallel">
<p>We could conceivably ditch the pointer too by having parallel arrays for the hot
and cold components. Then we can find the cold AI data for a component since
both pieces will be at the same index in their respective arrays.</p>
</aside>
<p>You can see how this starts to get fuzzy, though. In my example here, it&#8217;s
pretty obvious which data should be hot and cold, but in a real game it&#8217;s
rarely so clear-cut.
What if you have fields that are used when an entity is in a certain mode but
not in others? What if entities use a certain chunk of data only when they&#8217;re in
certain parts of the level?</p>
<p>Doing this kind of optimization is somewhere between a black art and a rathole.
It&#8217;s easy to get sucked in and spend endless time pushing data around to see
what speed difference it makes. It will take practice to get a handle on where
to spend your effort.</p>
<h2><a href="#design-decisions" name="design-decisions">Design Decisions</a></h2>
<p>This pattern is really about a mindset&#8202;&mdash;&#8202;it&#8217;s getting you to think about your
data&#8217;s arrangement in memory as a key part of your game&#8217;s performance story. The
actual concrete design space is wide open. You can let <span name="dod">data
locality</span> affect your whole architecture, or maybe it&#8217;s just a localized
pattern you apply to a few core data structures.</p>
<p>The biggest questions you&#8217;ll need to answer are when and where you apply this
pattern, but here are a couple of others that may come up.</p>
<aside name="dod">
<p>Noel Llopis&#8217; <a href="http://gamesfromwithin.com/data-oriented-design">famous article</a>
that got a lot more people thinking about designing games around cache usage
calls this &#8220;data-oriented design&#8221;.</p>
</aside>
<h3><a href="#how-do-you-handle-polymorphism" name="how-do-you-handle-polymorphism">How do you handle polymorphism?</a></h3>
<p>Up to this point, we&#8217;ve avoided subclassing and virtual methods. We have assumed we
have nice packed arrays of <em>homogenous</em> objects. That way, we know they&#8217;re all
the exact same size. But polymorphism and dynamic dispatch are useful tools
too. How do we reconcile this?</p>
<ul>
<li>
<p><strong>Don&#8217;t:</strong></p>
<p>The <span name="type">simplest</span> answer is to avoid subclassing,
or at least avoid it in places where you&#8217;re optimizing for cache usage.
Software engineer culture is drifting away from heavy use of inheritance
anyway.</p>
<aside name="type">
<p>One way to keep much of the flexibility of polymorphism without using
subclassing is through the <a href="type-object.html" class="pattern">Type
Object</a> pattern.</p>
</aside>
<ul>
<li>
<p><em>It&#8217;s safe and easy.</em> You know exactly what class you&#8217;re dealing with,
    and all objects are obviously the same size.</p>
</li>
<li>
<p><em>It&#8217;s faster.</em> Dynamic dispatch means looking up the method in the
    vtable and then traversing that pointer to get to the actual code. While
    the cost of this varies widely across different hardware, there is <span
    name="cpp"><em>some</em></span> cost to dynamic dispatch.</p>
</li>
</ul>
<aside name="cpp">
<p>As usual, the only absolute is that there are no absolutes. In most cases, a
C++ compiler will require an indirection for a virtual method call. But in
<em>some</em> cases, the compiler may be able to do <em>devirtualization</em> and
statically call the right method if it knows what concrete type the receiver
is. Devirtualization is more common in just-in-time compilers for languages
like Java and JavaScript.</p>
</aside>
<ul>
<li><em>It&#8217;s inflexible.</em> Of course, the reason we use dynamic dispatch is
    because it gives us a powerful way to vary behavior between objects. If
    you want different entities in your game to have their own rendering
    styles or their own special moves and attacks, virtual methods are a
    proven way to model that. Having to instead stuff all of that code into
    a single non-virtual method that does something like a big <code>switch</code> gets
    messy quickly.</li>
</ul>
</li>
<li>
<p><strong>Use separate arrays for each type:</strong></p>
<p>We use polymorphism so that we can invoke behavior on an object whose type
we don&#8217;t know. In other words, we have a mixed bag of stuff, and we want each
object in there to do its own thing when we tell it to go.</p>
<p>But that raises the question of why mix the bag to begin with? Instead,
why not maintain separate, homogenous collections for each type?</p>
<ul>
<li>
<p><em>It keeps objects tightly packed.</em> Since each array only contains
    objects of one class, there&#8217;s no padding or other weirdness.</p>
</li>
<li>
<p><em>You can statically dispatch.</em> Once you&#8217;ve got objects partitioned by
    type, you don&#8217;t need polymorphism at all any more. You can use
    regular, non-virtual method calls.</p>
</li>
<li>
<p><em>You have to keep track of a bunch of collections.</em> If you have a lot of
    different object types, the overhead and complexity of maintaining
    separate arrays for each can be a chore.</p>
</li>
<li>
<p><em>You have to be aware of every type</em>. Since you have to maintain
    separate collections for each type, you can&#8217;t be decoupled from the
    <em>set</em> of classes. Part of the magic of polymorphism is that it&#8217;s
    <em>open-ended</em>&#8202;&mdash;&#8202;code that works with an interface can be completely
    decoupled from the potentially large set of types that implement that
    interface.</p>
</li>
</ul>
</li>
<li>
<p><strong>Use a collection of pointers:</strong></p>
<p>If you weren&#8217;t worried about caching, this is the natural solution. Just
have an array of pointers to some base class or interface type. You get all the
polymorphism you could want, and objects can be whatever size they want.</p>
<ul>
<li>
<p><em>It&#8217;s flexible.</em> The code that consumes the collection can work with
    objects of any type as long as it supports the interface you care about.
    It&#8217;s completely open-ended.</p>
</li>
<li>
<p><em>It&#8217;s less cache-friendly.</em> Of course, the whole reason we&#8217;re discussing
    other options here is because this means cache-unfriendly pointer
    indirection. But, remember, if this code isn&#8217;t performance-critical,
    that&#8217;s probably OK.</p>
</li>
</ul>
</li>
</ul>
<h3><a href="#how-are-game-entities-defined" name="how-are-game-entities-defined">How are game entities defined?</a></h3>
<p>If you use this pattern in tandem with the <a href="component.html"
class="pattern">Component</a> pattern, you&#8217;ll have nice contiguous arrays for
all of the components that make up your game entities. The game loop will be
iterating over those directly, so the object for the game entity itself is less
important, but it&#8217;s still useful in other parts of the codebase where you want
to work with a single conceptual &#8220;entity&#8221;.</p>
<p>The question then is how should it be represented? How does it keep track of its
components?</p>
<ul>
<li>
<p><strong>If game entities are classes with pointers to their components:</strong></p>
<p>This is what our first example looked like. It&#8217;s sort of the vanilla OOP
solution. You&#8217;ve got a class for <code>GameEntity</code>, and it has pointers to the
components it owns. Since they&#8217;re just pointers, it&#8217;s agnostic about where
and how those components are organized in memory.</p>
<ul>
<li>
<p><em>You can store components in contiguous arrays.</em> Since the game entity
    doesn&#8217;t care where its components are, you can organize them in a nice
    packed array to optimize iterating over them.</p>
</li>
<li>
<p><em>Given an entity, you can easily get to its components.</em> They&#8217;re just a
    pointer indirection away.</p>
</li>
<li>
<p><em>Moving components in memory is hard.</em> When components get enabled or
    disabled, you may want to move them around in the array to keep the
    active ones up front and contiguous. If you move a component while the
    entity has a raw pointer to it, though, that pointer gets broken if you
    aren&#8217;t careful. You&#8217;ll have to make sure to update the entity&#8217;s pointer
    at the same time.</p>
</li>
</ul>
</li>
<li>
<p><strong>If game entities are classes with IDs for their components:</strong></p>
<p>The challenge with raw pointers to components is that it makes it harder to
move them around in memory. You can address that by using something more
abstract: an ID or index that can be used to <em>look up</em> a component.</p>
<p>The actual semantics of the ID and lookup process are up to you. It could be
as simple as storing a unique ID in each component and walking the array, or
more complex like a hash table that maps IDs to their current index in the
component array.</p>
<ul>
<li>
<p><em>It&#8217;s more complex.</em> Your ID system doesn&#8217;t have to be rocket science,
    but it&#8217;s still more work than a basic pointer. You&#8217;ll have to implement
    and debug it, and there will be memory overhead for bookkeeping.</p>
</li>
<li>
<p><em>It&#8217;s slower</em>. It&#8217;s hard to beat traversing a raw pointer. There may be
    some searching or hashing involved to get from an entity to one
    of its components.</p>
</li>
<li>
<p><em>You&#8217;ll need access to the component &#8220;manager&#8221;.</em> The basic idea is that
    you have some abstract ID that identifies a component. You can use it to
    get a reference to the actual component object. But to do that, you need
    to hand that ID to something that can actually find the component. That
    will be the class that wraps your raw contiguous array of component
    objects.</p>
<p>With raw pointers, if you have a game entity, you can find its
components. With this, you <span name="singleton">need</span> the game
entity <em>and the component registry too</em>.</p>
<aside name="singleton">
<p>You may be thinking, &#8220;I&#8217;ll just make it a singleton! Problem solved!&#8221;
Well, sort of. You might want to check out <a href="singleton.html">the
chapter</a> on those first.</p>
</aside>
</li>
</ul>
</li>
<li>
<p><strong>If the game entity is <em>itself</em> just an ID:</strong></p>
<p>This is a newer style that some game engines use. Once you&#8217;ve moved all of
your entity&#8217;s behavior and state out of the main class and into components,
what&#8217;s left? It turns out, not much. The only thing an entity does is bind a
set of components together. It exists just to say <em>this</em> AI component and
<em>this</em> physics component and <em>this</em> render component define one living
entity in the world.</p>
<p>That&#8217;s important because components interact. The render component needs to
know where the entity is, which may be a property of the physics component.
The AI component wants to move the entity, so it needs to apply a force to
the physics component. Each component needs a way to get the other sibling
components of the entity it&#8217;s a part of.</p>
<p>Some smart people realized all you need for that is an ID. Instead of the
entity knowing its components, the components know their entity. Each
component knows the ID of the entity that owns it. When the AI component
needs the physics component for its entity, it simply asks for the physics
component with the same entity ID that it holds.</p>
<p>Your entity <em>classes</em> disappear entirely, replaced by a glorified wrapper
around a number.</p>
<ul>
<li>
<p><em>Entities are tiny.</em> When you want to pass around a reference to a game
    entity, it&#8217;s just a single value.</p>
</li>
<li>
<p><em>Entities are empty.</em> Of course, the downside of moving everything out
    of entities is that you <em>have</em> to move everything out of entities. You
    no longer have a place to put non-component-specific state or behavior.
    This style doubles down on the <a href="component.html"
class="pattern">Component</a> pattern.</p>
</li>
<li>
<p><em>You don&#8217;t have to manage their lifetime.</em> Since entities are just dumb
    value types, they don&#8217;t need to be explicitly allocated and freed. An
    entity implicitly &#8220;dies&#8221; when all of its components are destroyed.</p>
</li>
<li>
<p><em>Looking up a component for an entity may be slow.</em> This is the same
    problem as the previous answer, but in the opposite direction. To find a
    component for some entity, you have to map an ID to an object. That
    process may be costly.</p>
<p>This time, though, it <em>is</em> performance-critical. Components often
interact with their siblings during update, so you will need to find
components frequently. One solution is to make the &#8220;ID&#8221; of an entity
the index of the component in its array.</p>
<p>If every entity has the same set of components, then your component
arrays are completely parallel. The component in slot three of the AI
component array will be for the same entity that the physics component
in slot three of <em>its</em> array is associated with.</p>
<p>Keep in mind, though, that this <em>forces</em> you to keep those arrays in
parallel. That&#8217;s hard if you want to start sorting or packing them by
different criteria. You may have some entities with disabled physics and
others that are invisible. There&#8217;s no way to sort the physics and render
component arrays optimally for both cases if they have to stay in sync
with each other.</p>
</li>
</ul>
</li>
</ul>
<h2><a href="#see-also" name="see-also">See Also</a></h2>
<ul>
<li>
<p>Much of this chapter revolves around the <a href="component.html"
    class="pattern">Component</a> pattern, and that pattern is definitely one of the
    most common data structures that gets optimized for cache usage. In fact,
    using the Component pattern makes this optimization easier. Since entities
    are updated one &#8220;domain&#8221; (AI, physics, etc.) at a time, splitting them out
    into components lets you slice a bunch of entities into the right
    pieces to be cache-friendly.</p>
<p>But that doesn&#8217;t mean you can <em>only</em> use this pattern with components! Any
time you have performance-critical code that touches a lot of data, it&#8217;s
important to think about locality.</p>
</li>
<li>
<p>Tony Albrecht&#8217;s <a href="http://research.scee.net/files/presentations/gcapaustralia09/Pitfalls_of_Object_Oriented_Programming_GCAP_09.pdf"
    class="pdf">&#8220;Pitfalls of Object-Oriented Programming&#8221;</a> is probably the
    most widely-read introduction to designing your game&#8217;s data structures for
    cache-friendliness. It made a lot more people (including me!) aware of how
    big of a deal this is for performance.</p>
</li>
<li>
<p>Around the same time, Noel Llopis wrote a <a href="http://gamesfromwithin.com/data-oriented-design">very influential blog
    post</a> on the same topic.</p>
</li>
<li>
<p>This pattern almost invariably takes advantage of a contiguous array of
    homogenous objects. Over time, you&#8217;ll very likely be adding and removing
    objects from that array. The <a href="object-pool.html"
    class="pattern">Object Pool</a> pattern is about exactly that.</p>
</li>
<li>
<p>The <a href="http://gamadu.com/artemis/">Artemis</a> game engine is one of the first
    and better-known frameworks that uses simple IDs for game entities.</p>
</li>
</ul>
<nav>
  <span class="prev">&larr; <a href="optimization-patterns.html">Previous Chapter</a></span>
  <span class="next"><a href="dirty-flag.html">Next Chapter</a> &rarr;</span>
  <span class="toc">&equiv; <a href="/">The Book</a></span>
</nav>
</div>
</div>
<footer>&copy; 2009-2021 Robert Nystrom</footer>
</body>
</html>
