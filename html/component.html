<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />

<title>Game Programming Patterns / Behaving Patterns / Component</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />
<link href="http://fonts.googleapis.com/css?family=Source+Code+Pro|Lato:400,700,400italic,700italic" rel="stylesheet" type="text/css">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-1', 'gameprogrammingpatterns.com');
  ga('send', 'pageview');
</script>
</head>
<body id="top">
<div class="content">
<h1 class="book"><a href="index.html">Game Programming Patterns</a> / Behaving Patterns</h1>
<h1>Component</h1>
<div class="in-progress">
  <span class="dismiss">&times;</span>
  <p><strong>This book is a work in progress!</strong></p>

  <p>If you see a mistake, find something unclear, or have a suggestion, please <a href="https://github.com/munificent/game-programming-patterns/issues/new" target="_blank">file a ticket</a>. To know when new chapters are up, join the mailing list:</p>

  <!-- Begin MailChimp Signup Form -->
  <div id="mc_embed_signup">
  <form action="http://gameprogrammingpatterns.us7.list-manage.com/subscribe/post?u=0952ca43ed2536d6717766b88&amp;id=0c27329244" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
    <table>
      <tr>
        <td width="100%">
          <input type="email" value="" name="EMAIL" class="email" id="mce-EMAIL" placeholder="email address" required>
        </td>
        <td>
          <div class="spacer"></div>
        </td>
        <td>
          <input type="submit" value="Join" name="subscribe" id="mc-embedded-subscribe" class="button">
        </td>
      </tr>
    </table>
  </form>
  </div>
  <!--End mc_embed_signup-->

  <table width="100%">
    <tr>
      <td width="50%">
        <p>Thank you!</p>
      </td>
      <td width="50%">
        <p class="signature">&mdash; Bob (<a href="https://twitter.com/intent/user?screen_name=munificentbob" target="_blank">@munificentbob</a>)</p>
      </td>
    </tr>
  </table>
</div>
<h2><a href="#intent" name="intent">Intent</a></h2>
<p><em>Allow a single class to bridge multiple domains without coupling the
domains to each other.</em></p>
<h2><a href="#motivation" name="motivation">Motivation</a></h2>
<p>Let&#x2019;s say we&#x2019;re building a platformer. The Italian plumber demographic
is covered, so ours will be starring a Danish <span name="baker">baker</span>,
Bj&oslash;rn. It stands to reason that we&#x2019;ll have a class representing our
friendly pastry chef, and it will contain everything he does in the game.</p>
<aside name="baker">

<p>Brilliant game ideas like this are why I&#x2019;m a programmer and not a
designer.</p>
</aside>

<p>Since the player controls him, that means reading controller input
and translating that to motion. And, of course, he needs to interact
with the level, so some physics and collision goes in there. Once that&#x2019;s done, he&#x2019;s got to show up on screen, so toss in animation and
rendering. He&#x2019;ll probably play some sounds too.</p>
<p>Hold on a minute; this is getting out of control. Software
Architecture 101 tells us that different domains in a program should
be kept isolated from each other. If we&#x2019;re making a word processor,
the code that handles printing shouldn&#x2019;t be affected by the code that
loads and saves documents. A game doesn&#x2019;t have the same domains as a
business app, but the rule still applies.</p>
<p>As much as possible, we don&#x2019;t want AI, physics, rendering, sound and
other domains to know about each other, but now we&#x2019;ve got all of that
crammed into one class. We&#x2019;ve seen where this road leads to: a 5,000
line dumping ground source file so big that only the bravest ninja
coders on your team even dare to go in there.</p>
<p>This is great job security for the few who can tame it, but hell for
the rest of us. A class that big means even the most seemingly trivial
changes can have far-reaching implications. Soon the class collects
<em>bugs</em> faster than it collects <em>features</em>.</p>
<h3><a href="#the-gordian-knot" name="the-gordian-knot">The Gordian knot</a></h3>
<p>Even worse than the simple scale problem is the <span name="coupling">coupling
</span> one. All of the different systems in our game have been tied into a
giant knotted ball of code like:</p>
<div class="codehilite"><pre><span class="k">if</span> <span class="p">(</span><span class="n">collidingWithFloor</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">getRenderState</span><span class="p">()</span> <span class="o">!=</span> <span class="n">INVISIBLE</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">playSound</span><span class="p">(</span><span class="n">HIT_FLOOR</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>Any programmer trying to make a change in code like that will need to
know something about physics, graphics, and sound just to make sure
they don&#x2019;t break anything.</p>
<aside name="coupling">

<p>While coupling like this sucks in <em>any</em> game, it&#x2019;s even worse on
modern games that use concurrency. On multi-core hardware, it&#x2019;s vital
that code is running on multiple threads simultaneously. One common
way to split a game across threads is along domain boundaries: run AI
on one core, sound on another, rendering on a third, etc.</p>
<p>Once you do that, it&#x2019;s critical that those domains stay decoupled in
order to avoid deadlocks or other fiendish concurrency bugs. Having a
single class with an <code>UpdateSounds()</code> method that must be called from
one thread and a <code>RenderGraphics()</code> method that must be called from
another is just begging for those kinds of bugs to happen.</p>
</aside>

<p>These two problems compound each other: the class touches so many
domains that every programmer will have to work on it, but its so huge
that doing so is a nightmare. If it gets bad enough, coders will start
putting hacks in other parts of the codebase just to stay out of the
hairball that this <code>Bjorn</code> class has become.</p>
<h3><a href="#cutting-the-knot" name="cutting-the-knot">Cutting the knot</a></h3>
<p>We can solve this like Alexander the Great: with a sword. We&#x2019;ll take
our monolithic <code>Bjorn</code> class and slice it into separate parts along
domain boundaries. For example, we&#x2019;ll take all of the code for
handling user input and move it into a separate <code>InputComponent</code>
class. <code>Bjorn</code> will then own an instance of this component. We repeat
this process for each of the domains that Bj&oslash;rn touches.</p>
<p>When we&#x2019;re done, we&#x2019;ll have moved almost everything out of <code>Bjorn</code>.
All that remains is a thin shell that binds the components together.
We&#x2019;ve solved our huge class problem by simply dividing it up into
multiple smaller classes, but we&#x2019;ve accomplished more than just that.</p>
<h3><a href="#loose-ends" name="loose-ends">Loose ends</a></h3>
<p>Our component classes are now decoupled. Even though <code>Bjorn</code> has a
<code>PhysicsComponent</code> and a <code>GraphicsComponent</code>, the two don&#x2019;t know about
each other. This means the person working on physics can modify their
component without needing to know anything about graphics and vice
versa.</p>
<p>In practice, the components will need to have <em>some</em> interaction
between themselves. For example, the AI component may need to tell the
physics component where Bj&oslash;rn is trying to go. However, we can
restrict this to just the components that <em>do</em> need to talk instead of
just tossing them all in the same playpen together.</p>
<h3><a href="#tying-back-together" name="tying-back-together">Tying back together</a></h3>
<p>Another feature of this design is that the
<span name="inheritance">components</span> are now reusable
packages. So far, we&#x2019;ve focused on our baker, but let&#x2019;s consider a
couple of other kinds of objects in our game world. <em>Decorations</em> are
things in the world the player sees but doesn&#x2019;t interact with: bushes,
debris and other visual detail. <em>Props</em> are like decorations but can
be touched: boxes, boulders, and trees. <em>Zones</em> are the opposite of
decorations: invisible but interactive. They&#x2019;re useful for things like
triggering a cutscene when Bj&oslash;rn enters an area.</p>
<aside name="inheritance">

<p>When object-oriented programming first hit the scene, inheritance was
the shiniest tool in its toolbox. It was considered the ultimate
code-reuse hammer and coders swung it often. Since then, we&#x2019;ve learned
the hard way that it&#x2019;s a heavy hammer indeed. Inheritance has its
uses, but it&#x2019;s often too cumbersome for simple code reuse.</p>
<p>Instead, the growing trend in software design is to use composition
instead of inheritance when possible. Instead of sharing code between
two classes by having them <em>inherit</em> from the same class, we do so by
having them both <em>own an instance</em> of the same class.</p>
</aside>

<p>Now consider how we&#x2019;d set up an inheritance hierarchy for those
classes if we weren&#x2019;t using components. A first pass might look like:</p>
<div class="codehilite"><pre>option a<span class="o">:</span> reuse collision code
         <span class="o">+---------+</span>
         <span class="o">|</span>game obj <span class="o">|</span>
         <span class="o">+---------+</span>
           <span class="o">/</span>     \
          <span class="o">/</span>       \
<span class="o">+------------+</span>  <span class="o">+------------+</span>
<span class="o">|</span>zone        <span class="o">|</span>  <span class="o">|</span>decoration  <span class="o">|</span>
<span class="o">|</span>collision<span class="o">&amp;</span>hellip<span class="p">;</span><span class="o">|</span>  <span class="o">|</span>rendering<span class="o">&amp;</span>hellip<span class="p">;</span><span class="o">|</span>
<span class="o">+------------+</span>  <span class="o">+------------+</span>
    <span class="o">|</span>
<span class="o">+------------+</span>        <span class="o">^</span>
<span class="o">|</span>prop        <span class="o">|</span>    rendering is
<span class="o">|</span>rendering<span class="o">&amp;</span>hellip<span class="p">;</span><span class="o">|</span> <span class="o">&lt;-</span> duplicated
<span class="o">+------------+</span>
</pre></div>


<p>We have a base <code>GameObject</code> class that has common stuff like position
and orientation. <code>Zone</code> inherits from that and adds collision
detection. Likewise, <code>Decoration</code> inherits from <code>GameObject</code> and adds
rendering. <code>Prop</code> inherits from <code>Zone</code>, so it can reuse the collision
code. However, <code>Prop</code> can&#x2019;t <em>also</em> inherit from <code>Decoration</code> to reuse
the rendering code without running into the
<span name="diamond">Deadly Diamond</span>.</p>
<aside name="diamond">

<p>The &ldquo;Deadly Diamond&rdquo; occurs in class hierarchies with
multiple inheritance where there are two different paths to the same
base class. The pain that causes is a bit out of the scope of this
book, but just understand that they named it &ldquo;deadly&rdquo; for
a reason.</p>
</aside>

<p>We could flip things around so that <code>Prop</code> inherits from <code>Decoration</code>,
but then we end up having to duplicate the collision code. Either way,
there&#x2019;s no clean way to reuse the collision and rendering code between
the classes that need it without resorting to multiple inheritance.
The only other option is to push everything up into <code>GameObject</code>, but
then <code>Zone</code> is wasting memory on rendering data it doesn&#x2019;t need and
<code>Decoration</code> is doing the same with physics.</p>
<p>Now lets try it with components. Our <span name="menu">subclasses disappear completely.
Instead, we have a single <code>GameObject</code> class and two component
classes: <code>PhysicsComponent</code> and <code>GraphicsComponent</code>. A decoration is
simply a <code>GameObject</code> with a <code>GraphicsComponent</code> but no
<code>PhysicsComponent</code>, A zone is the opposite, and a prop has both
components. No code duplication, no multiple inheritance, and only
three classes instead of four.</p>
<aside name="menu">

<p>A restaurant menu is a good analogy. Defining classes for each entity
is a menu that only lets you order combos. We need to have a separate
class for each possible <em>combination</em> of features. To satisfy every
customer, we need dozens of combos. Components are &agrave; la carte: each customer can select just the dishes they want, and the menu is just a list of the dishes they can choose from.</p>
</aside>

<p>Components are basically plug-and-play for objects. They let us build
complex entities with rich behavior by just plugging in different
reusable component objects into sockets on the entity. Think software
Voltron.</p>
<h2><a href="#the-pattern" name="the-pattern">The Pattern</a></h2>
<p>Split a monolithic class that spans multiple different domains into a
set of <strong><span name="component">component</span> classes</strong>. Each component encapsulates the portion
of the original class&#x2019;s behavior that is specific to one domain. The
original monolithic class becomes a <strong>container</strong> class that is a
shell for these components.</p>
<aside name="component">

<p>&ldquo;Component&rdquo;, like &ldquo;Object&rdquo;, is one of those
words that means everything and nothing in programming. Because of
that, it&#x2019;s been used to describe a few concepts. In business software,
there&#x2019;s a &ldquo;Component&rdquo; design pattern that describes
decoupled services that communicate over the web.</p>
<p>I tried to find a different name for this unrelated pattern found in
games, but &ldquo;Component&rdquo; seems to be the most common term
for it. Since design patterns are about documenting existing
practices, I don&#x2019;t have the luxury of coining a new term. So,
following in the footsteps of XNA, Delta3D, and others,
&ldquo;Component&rdquo; it is.</p>
</aside>

<h2><a href="#when-to-use-it" name="when-to-use-it">When to Use It</a></h2>
<p>Components are most commonly found within the core class that defines
the entities in a game, but may be useful in other places as well.
This pattern can be put to good use when any of these is true:</p>
<ul>
<li>
<p>You have a class that touches multiple domains which you want to
    keep decoupled from each other.</p>
</li>
<li>
<p>A class is getting massive and hard to work with.</p>
</li>
<li>
<p>You want to be able to define a variety of objects that share
    different capabilities, but using inheritance doesn&#x2019;t let you pick
    just the parts you want to reuse precisely enough.</p>
</li>
</ul>
<h2><a href="#keep-in-mind" name="keep-in-mind">Keep in Mind</a></h2>
<p>This pattern adds a good bit of complexity over simply making a class
and putting code in it. Each conceptual &ldquo;object&rdquo; becomes a
cluster of objects that must be instantiated, initialized, and
correctly wired together. Communication between the different
components becomes more challenging, and controlling how they occupy
memory is more complex.</p>
<p>For a large codebase, this complexity may be worth it for the
decoupling and code reuse it enables, but take care to ensure you
aren&#x2019;t over-engineering a &ldquo;solution&rdquo; to a non-existent
problem before applying this pattern.</p>
<p>Another consequence of using components is that you often have to hop
through a level of indirection to get anything done. Given the
container object, first you have to get the component you want, <em>then</em>
you can do what you need. In <span name="perf">performance</span> critical inner loops, this
pointer following may lead to poor performance.</p>
<aside name="perf">

<p>There&#x2019;s a flip side to this coin. The Component pattern can often
<em>improve</em> performance and cache coherence. Components are a prime
candidate for use in the <a class="pattern"
href="structure-of-arrays.html">Structure of Arrays</a> pattern, which
addresses a performance problem caused by monolithic objects.</p>
</aside>

<h2><a href="#sample-code" name="sample-code">Sample Code</a></h2>
<p>One of the biggest challenges for me in writing this book is figuring
out how to isolate each pattern. Many design patterns exist to contain
code that itself isn&#x2019;t part of the pattern. In order to distill the
pattern down to its essence, I try to cut as much of that out as
possible, but at some point it becomes a bit like explaining how an
engine works without mentioning fuel or oil.</p>
<p>The Component pattern is a particularly hard one. You can&#x2019;t get a real
feel for it without seeing some code for each of the domains that it
decouples, so I&#x2019;ll have to sketch in a bit more of Bj&oslash;rn&#x2019;s code
than I&#x2019;d like to. The pattern is really just the component <em>classes</em>
themselves, but the code in them should help clarify what the classes
are for. It&#x2019;s fake code&thinsp;&mdash;&thinsp;it calls into other classes that aren&#x2019;t
presented here&thinsp;&mdash;&thinsp;but it should give you an idea of what we&#x2019;re
going for.</p>
<h3><a href="#a-monolithic-class" name="a-monolithic-class">A monolithic class</a></h3>
<p>To get a clearer picture of how this pattern is applied, we&#x2019;ll start by showing a monolithic <span name="cat"><code>Bjorn</code></span> class that does everything we need but <em>doesn&#x2019;t</em> use this pattern:</p>
<aside name="cat">

<p>I should point out that using the actual name of the character in the
codebase is usually a bad idea. The marketing department has an
annoying habit of demanding name changes days before you ship.
&ldquo;Focus tests show males between 11 and 15 respond negatively to
&lsquo;Bj&oslash;rn&rsquo;. Use &lsquo;Sven&rsquo; instead.&rdquo;</p>
<p>This is why many software projects use internal-only codenames. Well,
that and because it&#x2019;s more fun to tell people you&#x2019;re working on
&ldquo;Big Electric Cat&rdquo; than just &ldquo;the next version of
Photoshop.&rdquo;</p>
</aside>

<div class="codehilite"><pre><span class="k">class</span> <span class="nc">Bjorn</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="n">World</span><span class="o">&amp;</span> <span class="n">world</span><span class="p">,</span> <span class="n">Graphics</span><span class="o">&amp;</span> <span class="n">graphics</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Apply user input to hero&#39;s velocity.</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">Controller</span><span class="o">::</span><span class="n">getJoystickDirection</span><span class="p">())</span>
    <span class="p">{</span>
      <span class="k">case</span> <span class="n">DIR_LEFT</span>:  <span class="n">velocity_</span> <span class="o">-=</span> <span class="n">WALK_ACCELERATION</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="n">DIR_RIGHT</span>: <span class="n">velocity_</span> <span class="o">+=</span> <span class="n">WALK_ACCELERATION</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Modify position by velocity.</span>
    <span class="n">x_</span> <span class="o">+=</span> <span class="n">velocity_</span><span class="p">;</span>
    <span class="n">world</span><span class="p">.</span><span class="n">resolveCollision</span><span class="p">(</span><span class="n">volume_</span><span class="p">,</span> <span class="n">x_</span><span class="p">,</span> <span class="n">y_</span><span class="p">,</span> <span class="n">velocity_</span><span class="p">);</span>

    <span class="c1">// Draw the appropriate sprite.</span>
    <span class="n">Sprite</span><span class="o">*</span> <span class="n">sprite</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">spriteStand_</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">velocity_</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">sprite</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">spriteWalkLeft_</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">velocity_</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">sprite</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">spriteWalkRight_</span><span class="p">;</span>

    <span class="n">graphics</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="o">*</span><span class="n">sprite</span><span class="p">,</span> <span class="n">x_</span><span class="p">,</span> <span class="n">y_</span><span class="p">);</span>
  <span class="p">}</span>

<span class="nl">private:</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">WALK_ACCELERATION</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">velocity_</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">x_</span><span class="p">,</span> <span class="n">y_</span><span class="p">;</span>

  <span class="n">Volume</span> <span class="n">volume_</span><span class="p">;</span>

  <span class="n">Sprite</span> <span class="n">spriteStand_</span><span class="p">;</span>
  <span class="n">Sprite</span> <span class="n">spriteWalkLeft_</span><span class="p">;</span>
  <span class="n">Sprite</span> <span class="n">spriteWalkRight_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p><code>Bjorn</code> has an <code>update()</code> method that gets called once per frame by
the game. It reads the joystick to determine how to accelerate the
baker. Then it resolves its new position with the physics engine.
Finally, it draws Bj&oslash;rn onto the screen.</p>
<p>The sample implemention here is trivially simple. There&#x2019;s no gravity,
animation, or any of the dozens of other details that make a character
fun to play. Even so, we can see that we&#x2019;ve got a single function that
several different coders on our team will probably have to spend time
in and it&#x2019;s starting to get a bit messy. Imagine this scaled up to
a thousand lines and you can get an idea of how painful it can become.</p>
<h3><a href="#splitting-out-a-domain" name="splitting-out-a-domain">Splitting out a domain</a></h3>
<p>Starting with one domain, lets pull a piece out of <code>Bjorn</code> and push it
into a separate component class. We&#x2019;ll start with the first domain
that gets processed: input. The first thing <code>Bjorn</code> does is read in
user input and adjust his velocity based on it. Let&#x2019;s move that logic
out into a separate class:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">InputComponent</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="n">Bjorn</span><span class="o">&amp;</span> <span class="n">bjorn</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">Controller</span><span class="o">::</span><span class="n">getJoystickDirection</span><span class="p">())</span>
    <span class="p">{</span>
      <span class="k">case</span> <span class="n">DIR_LEFT</span>:  <span class="n">bjorn</span><span class="p">.</span><span class="n">velocity</span> <span class="o">-=</span> <span class="n">WALK_ACCELERATION</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="n">DIR_RIGHT</span>: <span class="n">bjorn</span><span class="p">.</span><span class="n">velocity</span> <span class="o">+=</span> <span class="n">WALK_ACCELERATION</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

<span class="nl">private:</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">WALK_ACCELERATION</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>Pretty simple. We&#x2019;ve taken the first section of <code>Bjorn</code>&#x2019;s <code>update()</code>
method and put it into this class. The changes to <code>Bjorn</code> are also straightforward:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">Bjorn</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">int</span> <span class="n">velocity</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>

  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span><span class="n">World</span><span class="o">&amp;</span> <span class="n">world</span><span class="p">,</span> <span class="n">Graphics</span><span class="o">&amp;</span> <span class="n">graphics</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">input_</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>

    <span class="c1">// Modify position by velocity.</span>
    <span class="n">x</span> <span class="o">+=</span> <span class="n">velocity</span><span class="p">;</span>
    <span class="n">world</span><span class="p">.</span><span class="n">resolveCollision</span><span class="p">(</span><span class="n">volume_</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">velocity</span><span class="p">);</span>

    <span class="c1">// Draw the appropriate sprite.</span>
    <span class="n">Sprite</span><span class="o">*</span> <span class="n">sprite</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">spriteStand_</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">velocity</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">sprite</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">spriteWalkLeft_</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">velocity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">sprite</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">spriteWalkRight_</span><span class="p">;</span>

    <span class="n">graphics</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="o">*</span><span class="n">sprite</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
  <span class="p">}</span>

<span class="nl">private:</span>
  <span class="n">InputComponent</span> <span class="n">input_</span><span class="p">;</span>

  <span class="n">Volume</span> <span class="n">volume_</span><span class="p">;</span>

  <span class="n">Sprite</span> <span class="n">spriteStand_</span><span class="p">;</span>
  <span class="n">Sprite</span> <span class="n">spriteWalkLeft_</span><span class="p">;</span>
  <span class="n">Sprite</span> <span class="n">spriteWalkRight_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p><code>Bjorn</code> now owns an <code>InputComponent</code> object. Where before he was
handling user input directly in the <code>update()</code> method, now he
delegates to the component:</p>
<div class="codehilite"><pre><span class="n">input_</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
</pre></div>


<p>We&#x2019;ve only started but already we&#x2019;ve gotten rid of some coupling: the main
<code>Bjorn</code> class no longer has any reference to <code>Controller</code>. This will come in
handy later.</p>
<h3><a href="#splitting-out-the-rest" name="splitting-out-the-rest">Splitting out the rest</a></h3>
<p>Now let&#x2019;s go ahead and do the same cut and paste job on the physics
and graphics code. Here&#x2019;s our new <code>PhysicsComponent</code>:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">PhysicsComponent</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="n">Bjorn</span><span class="o">&amp;</span> <span class="n">bjorn</span><span class="p">,</span> <span class="n">World</span><span class="o">&amp;</span> <span class="n">world</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">bjorn</span><span class="p">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">bjorn</span><span class="p">.</span><span class="n">velocity</span><span class="p">;</span>
    <span class="n">world</span><span class="p">.</span><span class="n">resolveCollision</span><span class="p">(</span><span class="n">volume_</span><span class="p">,</span> <span class="n">bjorn</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">bjorn</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">bjorn</span><span class="p">.</span><span class="n">velocity</span><span class="p">);</span>
  <span class="p">}</span>

<span class="nl">private:</span>
  <span class="n">Volume</span> <span class="n">volume_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>In addition to moving the physics <em>behavior</em> out of the main <code>Bjorn</code> class, you
can see we&#x2019;ve also moved out the <em>data</em> too: The <code>Volume</code> object is now owned
by the component.</p>
<p>Last but not least, here&#x2019;s where the rendering code lives now:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">GraphicsComponent</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="n">Bjorn</span><span class="o">&amp;</span> <span class="n">bjorn</span><span class="p">,</span> <span class="n">Graphics</span><span class="o">&amp;</span> <span class="n">graphics</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">Sprite</span><span class="o">*</span> <span class="n">sprite</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">spriteStand_</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">bjorn</span><span class="p">.</span><span class="n">velocity</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">sprite</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">spriteWalkLeft_</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bjorn</span><span class="p">.</span><span class="n">velocity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">sprite</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">spriteWalkRight_</span><span class="p">;</span>

    <span class="n">graphics</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="o">*</span><span class="n">sprite</span><span class="p">,</span> <span class="n">bjorn</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">bjorn</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
  <span class="p">}</span>

<span class="nl">private:</span>
  <span class="n">Sprite</span> <span class="n">spriteStand_</span><span class="p">;</span>
  <span class="n">Sprite</span> <span class="n">spriteWalkLeft_</span><span class="p">;</span>
  <span class="n">Sprite</span> <span class="n">spriteWalkRight_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>We&#x2019;ve yanked almost everything out, so what&#x2019;s left of our humble pastry chef?
Not much:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">Bjorn</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">int</span> <span class="n">velocity</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>

  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span><span class="n">World</span><span class="o">&amp;</span> <span class="n">world</span><span class="p">,</span> <span class="n">Graphics</span><span class="o">&amp;</span> <span class="n">graphics</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">input_</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
    <span class="n">physics_</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">world</span><span class="p">);</span>
    <span class="n">graphics_</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">graphics</span><span class="p">);</span>
  <span class="p">}</span>

<span class="nl">private:</span>
  <span class="n">InputComponent</span>    <span class="n">input_</span><span class="p">;</span>
  <span class="n">PhysicsComponent</span>  <span class="n">physics_</span><span class="p">;</span>
  <span class="n">GraphicsComponent</span> <span class="n">graphics_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>The <code>Bjorn</code> class now basically does two things: it holds the set of
components that actually define it, and it holds the state that is
shared across multiple domains. Position and velocity are still in the
core <code>Bjorn</code> class for two reasons. First, they are
&ldquo;pan-domain&rdquo; state: almost every component will make use
of them, so it isn&#x2019;t clear which component <em>should</em> own them if we did
want to push them down.</p>
<p>Secondly, and more importantly, it gives us an easy way for the
components to communicate without being coupled to each other. Let&#x2019;s
see if we can put that to use.</p>
<h3><a href="#robo-bj&oslash;rn" name="robo-bj&oslash;rn">Robo-Bj&oslash;rn</a></h3>
<p>So far, we&#x2019;ve pushed our behavior out to separate component classes,
but we haven&#x2019;t <em>abstracted</em> the behavior out. <code>Bjorn</code> still knows the
exact concrete classes where his behavior is defined. Let&#x2019;s change
that.</p>
<p>We&#x2019;ll take our component for handling user input and hide it behind an
interface. We&#x2019;ll turn <code>InputComponent</code> into an abstract base class:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">InputComponent</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="n">Bjorn</span><span class="o">&amp;</span> <span class="n">bjorn</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>Then we&#x2019;ll take our existing user input handling code and push it
down into a class that implements that interface:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">PlayerInputComponent</span> <span class="o">:</span> <span class="k">public</span> <span class="n">InputComponent</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="n">Bjorn</span><span class="o">&amp;</span> <span class="n">bjorn</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">Controller</span><span class="o">::</span><span class="n">getJoystickDirection</span><span class="p">())</span>
    <span class="p">{</span>
      <span class="k">case</span> <span class="n">DIR_LEFT</span>:  <span class="n">bjorn</span><span class="p">.</span><span class="n">velocity</span> <span class="o">-=</span> <span class="n">WALK_ACCELERATION</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="n">DIR_RIGHT</span>: <span class="n">bjorn</span><span class="p">.</span><span class="n">velocity</span> <span class="o">+=</span> <span class="n">WALK_ACCELERATION</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

<span class="nl">private:</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">WALK_ACCELERATION</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>We&#x2019;ll change <code>Bjorn</code> to hold a pointer to the input component, instead
of owning an instance directly:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">Bjorn</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">int</span> <span class="n">velocity</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>

  <span class="n">Bjorn</span><span class="p">(</span><span class="n">InputComponent</span><span class="o">*</span> <span class="n">input</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">input_</span><span class="p">(</span><span class="n">input</span><span class="p">)</span>
  <span class="p">{}</span>

  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="n">World</span><span class="o">&amp;</span> <span class="n">world</span><span class="p">,</span> <span class="n">Graphics</span><span class="o">&amp;</span> <span class="n">graphics</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">input_</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
    <span class="n">physics_</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">world</span><span class="p">);</span>
    <span class="n">graphics_</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">graphics</span><span class="p">);</span>
  <span class="p">}</span>

<span class="nl">private:</span>
  <span class="n">InputComponent</span><span class="o">*</span>   <span class="n">input_</span><span class="p">;</span>
  <span class="n">PhysicsComponent</span>  <span class="n">physics_</span><span class="p">;</span>
  <span class="n">GraphicsComponent</span> <span class="n">graphics_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>Now, when we instantiate <code>Bjorn</code>, we can pass in an input component
for it to use, like so:</p>
<div class="codehilite"><pre><span class="n">Bjorn</span><span class="o">*</span> <span class="n">bjorn</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Bjorn</span><span class="p">(</span><span class="k">new</span> <span class="n">PlayerInputComponent</span><span class="p">());</span>
</pre></div>


<p>This instance can be any concrete type that implements our abstract
<code>InputComponent</code> interface. We pay a price for this: <code>update()</code> is now
a virtual method call, which is a little slower. What do we get in
return for this cost?</p>
<p>Most consoles require a game to support &ldquo;demo mode.&rdquo; If
the player sits at the main menu without doing anything, the game will
start playing automatically, with the computer standing in for the
player. This keeps the game from burning the main menu into your TV,
and also makes the game look nicer when it&#x2019;s running on a kiosk in a
store.</p>
<p>Hiding the input component class behind an interface lets us get that
working. We already have our concrete <code>PlayerInputComponent</code> that&#x2019;s
normally used when playing the game. Now let&#x2019;s make another one:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">DemoInputComponent</span> <span class="o">:</span> <span class="k">public</span> <span class="n">InputComponent</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="n">Bjorn</span><span class="o">&amp;</span> <span class="n">bjorn</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// AI to automatically control Bjorn...</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<p>When the game goes into demo mode, instead of constructing
Bj&oslash;rn like we did earlier, we&#x2019;ll wire him up with our new
component:</p>
<div class="codehilite"><pre><span class="n">Bjorn</span><span class="o">*</span> <span class="n">bjorn</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Bjorn</span><span class="p">(</span><span class="k">new</span> <span class="n">DemoInputComponent</span><span class="p">());</span>
</pre></div>


<p>And now, just by swapping out a component, we&#x2019;ve got a fully
functioning computer-controlled player for demo mode. We&#x2019;re able to
reuse all of the other code for Bj&oslash;rn&thinsp;&mdash;&thinsp;physics and
graphics don&#x2019;t even know there&#x2019;s a difference. Maybe I&#x2019;m a bit
strange, but it&#x2019;s stuff like this that gets me up in the <span name="coffee">morning</span>.</p>
<aside name="coffee">

<p>That, and coffee.</p>
</aside>

<h3><a href="#no-bj&oslash;rn-at-all" name="no-bj&oslash;rn-at-all">No Bj&oslash;rn at all?</a></h3>
<p>If you look at our <code>Bjorn</code> class now, you&#x2019;ll notice there&#x2019;s nothing
really &ldquo;Bj&oslash;rn&rdquo; about it&thinsp;&mdash;&thinsp;it&#x2019;s just a
component bag. In fact, it looks like a pretty good candidate for a
base &ldquo;game object&rdquo; class that we can use for <em>every</em>
object in the game. All we need to do is pass in <em>all</em> the components,
and we can build any kind of object just by picking and choosing parts
like Dr. Frankenstein.</p>
<p>Let&#x2019;s take our two remaining concrete components&thinsp;&mdash;&thinsp;physics and graphics&thinsp;&mdash;&thinsp;and hide them behind interfaces like we did with input:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">PhysicsComponent</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="n">GameObject</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">,</span> <span class="n">World</span><span class="o">&amp;</span> <span class="n">world</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">GraphicsComponent</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="n">GameObject</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">,</span> <span class="n">Graphics</span><span class="o">&amp;</span> <span class="n">graphics</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>Then we re-christen <code>Bjorn</code> into a <span name="id">generic</span> <code>GameObject</code> class that
uses those interfaces:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">GameObject</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">int</span> <span class="n">velocity</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>

  <span class="n">GameObject</span><span class="p">(</span><span class="n">InputComponent</span><span class="o">*</span> <span class="n">input</span><span class="p">,</span>
             <span class="n">PhysicsComponent</span><span class="o">*</span> <span class="n">physics</span><span class="p">,</span>
             <span class="n">GraphicsComponent</span><span class="o">*</span> <span class="n">graphics</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">input_</span><span class="p">(</span><span class="n">input</span><span class="p">),</span>
    <span class="n">physics_</span><span class="p">(</span><span class="n">physics</span><span class="p">),</span>
    <span class="n">graphics_</span><span class="p">(</span><span class="n">graphics</span><span class="p">)</span>
  <span class="p">{}</span>

  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="n">World</span><span class="o">&amp;</span> <span class="n">world</span><span class="p">,</span> <span class="n">Graphics</span><span class="o">&amp;</span> <span class="n">graphics</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">input_</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
    <span class="n">physics_</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">world</span><span class="p">);</span>
    <span class="n">graphics_</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">graphics</span><span class="p">);</span>
  <span class="p">}</span>

<span class="nl">private:</span>
  <span class="n">InputComponent</span><span class="o">*</span>    <span class="n">input_</span><span class="p">;</span>
  <span class="n">PhysicsComponent</span><span class="o">*</span>  <span class="n">physics_</span><span class="p">;</span>
  <span class="n">GraphicsComponent</span><span class="o">*</span> <span class="n">graphics_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<aside name="id">

<p>Some component systems take this even farther. Instead of a <code>GameObject</code> that contains its components, the game entity is just an ID, a number. Then you maintain separate collections of components where each one knows the ID of the entity its attached to.</p>
<p>These <a href="http://en.wikipedia.org/wiki/Entity_component_system">entity component systems</a> take decoupling components to the extreme and let you add new components to an entity without the entity even knowing.</p>
</aside>

<p>Our existing concrete classes will get renamed and implement those interfaces:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">BjornInputComponent</span> <span class="o">:</span> <span class="k">public</span> <span class="n">InputComponent</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="n">GameObject</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// User input code...</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">BjornPhysicsComponent</span> <span class="o">:</span> <span class="k">public</span> <span class="n">PhysicsComponent</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="n">GameObject</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">,</span> <span class="n">World</span><span class="o">&amp;</span> <span class="n">world</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Physics code...</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">BjornGraphicsComponent</span> <span class="o">:</span> <span class="k">public</span> <span class="n">GraphicsComponent</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="n">GameObject</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">,</span> <span class="n">Graphics</span><span class="o">&amp;</span> <span class="n">graphics</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Graphics code...</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<p>And now we can build an object that has all of Bj&oslash;rn&#x2019;s original
behavior without having to actually create a class for him, just like
this:</p>
<p><span name="factory"></span></p>
<div class="codehilite"><pre><span class="n">GameObject</span><span class="o">*</span> <span class="nf">createBjorn</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="n">GameObject</span><span class="p">(</span><span class="k">new</span> <span class="n">PlayerInputComponent</span><span class="p">(),</span>
                        <span class="k">new</span> <span class="n">BjornPhysicsComponent</span><span class="p">(),</span>
                        <span class="k">new</span> <span class="n">BjornGraphicsComponent</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>


<aside name="factory">

<p>This <code>createBjorn()</code> function is, of course, an example of the classic
Gang of Four <a class="gof-pattern"
href="http://c2.com/cgi/wiki?FactoryMethod">Factory Method</a>
pattern.</p>
</aside>

<p>By defining other functions that instantiate <code>GameObjects</code> with
different components, we can create all of the different kinds of
objects our game needs.</p>
<h2><a href="#design-decisions" name="design-decisions">Design Decisions</a></h2>
<p>The most important design question you&#x2019;ll need to answer with this
pattern is &ldquo;What set of components do I need?&rdquo; The answer
there is going to depend on the needs and genre of your game. The
bigger and more complex your engine is, the more finely you&#x2019;ll likely
want to slice your components.</p>
<p>Beyond that, there are a couple of more specific options to consider:</p>
<h3><a href="#how-does-the-object-get-its-components" name="how-does-the-object-get-its-components">How does the object get its components?</a></h3>
<p>Once we&#x2019;ve split up our monolithic object into a few separate
component parts, we have to decide who puts the parts back together.</p>
<ul>
<li>
<p><strong>If the object creates its own components:</strong></p>
<ul>
<li>
<p><em>It ensures that the object always has the components it needs.</em>
    You never have to worry about someone forgetting to wire up the
    right components to the object and breaking the game. The
    container object itself takes care of it for you.</p>
</li>
<li>
<p><em>It&#x2019;s harder to reconfigure the object.</em> One of the powerful
    features of this pattern is that it lets you build new kinds of
    objects simply by recombining components. If our object always
    wires itself with the same set of hard-coded components, we aren&#x2019;t
    taking advantage of that flexibility.</p>
</li>
</ul>
</li>
<li>
<p><strong>If outside code provides the components:</strong></p>
<ul>
<li>
<p><em>The object becomes more flexible.</em> We can completely change the
    behavior of the object by giving it different components to work
    with. Taken to its fullest extent, our object becomes a generic
    component container that we can reuse over and over again for
    different purposes.</p>
</li>
<li>
<p><em>The object can be decoupled from the concrete component types.</em>
    If we&#x2019;re allowing outside code to pass in components, odds are
    good that we&#x2019;re also letting it pass in <em>derived</em> component types.
    At that point, the object only knows about the component
    <em>interfaces</em> and not the concrete types themselves. This can make
    for a nicely encapsulated architecture.</p>
</li>
</ul>
</li>
</ul>
<h3><a href="#how-do-components-communicate-with-each-other" name="how-do-components-communicate-with-each-other">How do components communicate with each other?</a></h3>
<p>Perfectly decoupled components that function in isolation is a nice
ideal, but doesn&#x2019;t really work in practice. The fact that these
components are part of the <em>same</em> object implies that they are part of
a larger whole and need to coordinate. That means communication.</p>
<p>So how can the components talk to each other? There are a couple of
options, but unlike most design &ldquo;alternatives&rdquo; in this
book, these aren&#x2019;t exclusive: you will likely support more than one at
the same time in your designs.</p>
<ul>
<li>
<p><strong>By modifying the container object&#x2019;s state:</strong></p>
<ul>
<li>
<p><em>It keeps the components decoupled.</em> When our <code>InputComponent</code> set
    Bj&oslash;rn&#x2019;s velocity and the PhysicsComponent later used it,
    the two components had no idea that the other even existed. For
    all they knew, Bj&oslash;rn&#x2019;s velocity could have changed through
    black magic.</p>
</li>
<li>
<p><em>It requires any information that components need to share to get
    pushed up into the container object.</em> Often, there&#x2019;s state that&#x2019;s
    really only needed by a subset of the components. For example, an
    animation and a rendering component may need to share information
    that&#x2019;s graphics-specific. Pushing that information up into the
    container object where <em>every</em> component can get to it muddies the
    object class.</p>
<p>Worse, if we use the same container object class with different
component configurations, we can end up wasting memory on state
that isn&#x2019;t needed by <em>any</em> of the object&#x2019;s components. If we push
some rendering-specific data into the container object, any
invisible object will be burning memory on it with no benefit.</p>
</li>
<li>
<p><em>It makes communication implicit and dependent on the order that
    components are processed.</em> In our sample code, the original
    monolithic <code>update()</code> method had a very carefully laid out order
    of operations: the user input modified the velocity, which was
    then used by the physics code to modify the position, which in
    turn was used by the rendering code to draw Bj&oslash;rn at the
    right spot. When we split that code out into components, we were
    careful to preserve that order of operations.</p>
<p>If we hadn&#x2019;t, we would have introduced <span name="pure">subtle</span>, hard to track bugs.
For example, if we&#x2019;d updated the graphics component <em>first</em>, we
would wrongly render Bj&oslash;rn at his position on the <em>last</em>
frame, not this one. If you imagine several more components and
lots more code, then you can get an idea of how hard it can be to
avoid bugs like this.</p>
<aside name="pure">

<p>Shared mutable state like this where lots of code is reading and
writing the same data is notoriously hard to get right. That&#x2019;s a
big part of why academics are spending time researching pure
functional languages like Haskell where there is no mutable state at
all.</p>
</aside>

</li>
</ul>
</li>
<li>
<p><strong>By referring directly to each other:</strong></p>
<ul>
<li>
<p>The idea here is that components that need to talk will have
    direct references to each other without having to go through the
    container object at all.</p>
<p>Let&#x2019;s say we want to let Bj&oslash;rn jump. The graphics code
needs to know if he should be drawn using a jump sprite or not. It
can determine this by asking the physics engine if he&#x2019;s currently
on the ground. An easy way to do this is by letting the graphics
component know about the physics component directly:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">GraphicsComponent</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">GraphicsComponent</span><span class="p">(</span><span class="n">PhysicsComponent</span><span class="o">*</span> <span class="n">physics</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">physics_</span><span class="p">(</span><span class="n">physics</span><span class="p">)</span>
  <span class="p">{}</span>

  <span class="kt">void</span> <span class="n">Update</span><span class="p">(</span><span class="n">Bjorn</span><span class="o">&amp;</span> <span class="n">bjorn</span><span class="p">,</span> <span class="n">Graphics</span><span class="o">&amp;</span> <span class="n">graphics</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">Sprite</span><span class="o">*</span> <span class="n">sprite</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">physics_</span><span class="o">-&gt;</span><span class="n">isOnGround</span><span class="p">())</span> <span class="n">sprite</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">spriteJump_</span><span class="p">;</span>
    <span class="k">else</span>
    <span class="p">{</span>
      <span class="c1">// Existing graphics code...</span>
    <span class="p">}</span>

    <span class="n">graphics</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="o">*</span><span class="n">sprite</span><span class="p">,</span> <span class="n">bjorn</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">bjorn</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
  <span class="p">}</span>

<span class="nl">private:</span>
  <span class="n">PhysicsComponent</span><span class="o">*</span> <span class="n">physics_</span><span class="p">;</span>

  <span class="n">Sprite</span> <span class="n">spriteStand_</span><span class="p">;</span>
  <span class="n">Sprite</span> <span class="n">spriteWalkLeft_</span><span class="p">;</span>
  <span class="n">Sprite</span> <span class="n">spriteWalkRight_</span><span class="p">;</span>
  <span class="n">Sprite</span> <span class="n">spriteJump_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>When we construct Bj&oslash;rn&#x2019;s <code>GraphicsComponent</code>, we&#x2019;ll give
it a reference to his corresponding <code>PhysicsComponent</code>.</p>
</li>
<li>
<p><em>It&#x2019;s simple and fast.</em> Communication is a direct method call from
    one object to another. The component can call any method that is
    supported by the component it has a reference to. It&#x2019;s a
    free-for-all.</p>
</li>
<li>
<p><em>The two components are tightly coupled.</em> The downside of the
    free-for-fall. We&#x2019;ve basically taken a step back towards our
    monolithic class. It&#x2019;s not quite as bad as the original single
    class though, since we&#x2019;re at least restricting the coupling to
    just the component pairs that need to interact.</p>
</li>
</ul>
</li>
<li>
<p><strong>By sending messages:</strong></p>
<ul>
<li>
<p>This is the most complex alternative. We can actually build a
    little messaging system into our container object and let the
    components broadcast information to each other.</p>
<p>Here&#x2019;s one possible implementation. We&#x2019;ll start by defining a base
<code>Component</code> interface that all of our components will implement:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">Component</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">receive</span><span class="p">(</span><span class="kt">int</span> <span class="n">message</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>It has a single <code>receive()</code> method that component classes
implement in order to listen to an incoming message. Here, we&#x2019;re
just using an <code>int</code> to identify the message, but a fuller
implementation could attach additional data to the message.</p>
<p>Then, we&#x2019;ll add a method to our container object for sending
messages:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">ContainerObject</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">send</span><span class="p">(</span><span class="kt">int</span> <span class="n">message</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_COMPONENTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">components_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">components_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">receive</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

<span class="nl">private:</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">MAX_COMPONENTS</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="n">Component</span><span class="o">*</span> <span class="n">components_</span><span class="p">[</span><span class="n">MAX_COMPONENTS</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>


<p>Now, if a component has access to its container, it can send
messages to it which will in turn be rebroadcast to all of its
sibling components. (And back to itself for that matter; be
careful that you don&#x2019;t get stuck in a feedback loop!) This has
a couple of consequences:</p>
</li>
<li>
<p><em>Sibling components are decoupled.</em> By going <span name="mediator">through</span> the parent
    container object, like our shared state alternative, we ensure
    that the components are still decoupled from each other. With this
    system, the only coupling they have is the message values
    themselves.</p>
<aside name="mediator">

<p>The Gang of Four call this the <a class="gof-pattern"
href="http://c2.com/cgi-bin/wiki?MediatorPattern">Mediator
Pattern</a>: two or more objects communicate with each other
indirectly by routing the message through an intermediate object. In
this case, the container object itself is the mediator.</p>
</aside>

</li>
<li>
<p><em>The container object is simple.</em> Unlike using shared state where
    the container object itself owns and knows about data used by the
    components, here all it does is blindly pass the messages along.
    That can be useful for letting two components pass very
    domain-specific information between themselves without having that
    bleed into the container object.</p>
</li>
</ul>
</li>
</ul>
<p>Unsurprisingly, there&#x2019;s no one best answer here. What you&#x2019;ll likely
end up doing is using a bit of all of them. Shared state is useful for
the really basic stuff that you can take for granted that every object
has&thinsp;&mdash;&thinsp;things like position and size.</p>
<p>Some domains are distinct but still closely related. Things like
animation and rendering, user input and AI, physics and collision. If
you have separate components for each half of those pairs, you may
find it easiest to just let them know directly about their other half.</p>
<p>Messaging is useful for &ldquo;less important&rdquo; communication.
Its fire-and-forget nature is a good fit for things like having an
audio component play a sound when a physics component sends a message
that the object has collided with something.</p>
<p>As always, I recommend you start simple, and then add in additional
communication paths if you need them.</p>
<h2><a href="#see-also" name="see-also">See Also</a></h2>
<ul>
<li>
<p>This pattern goes hand in hand with the <a class="pattern"
    href="structure-of-arrays">Structure of Arrays</a> pattern.
    Components split a monolithic object into separate smaller
    objects for each domain being used. If you get all of the
    components of the same type and put them in an array, now you&#x2019;ve
    got them laid out in memory just the way the Structure of Arrays
    pattern needs to improve your game&#x2019;s performance.</p>
<p>This is a rare hat trick in architecture: your code is both more
maintainable <em>and</em> faster.</p>
</li>
<li>
<p>The open source <a href="http://www.delta3d.org/">Delta3D</a>
    engine has a base <code>GameActor</code> class that implements this pattern
    with the appropriately named <code>ActorComponent</code> base class.</p>
</li>
<li>
<p>Microsoft&#x2019;s <a href="http://creators.xna.com/en-US/">XNA</a> game
    framework comes with a core <code>Game</code> class. It owns a collection of
    <code>GameComponent</code> objects. Where our example uses components at the
    individual game entity level, XNA implements the pattern at the
    level of the main game object itself, but the purpose is the same.</p>
</li>
<li>
<p>This pattern bears resemblance to the Gang of Four&#x2019;s <a
    class="gof-pattern"
    href="http://c2.com/cgi-bin/wiki?StrategyPattern">Strategy</a>
    pattern. Both patterns are about taking part of an object&#x2019;s
    behavior and delegating it to a separate subordinate object. The
    difference is that with the strategy pattern, the separate
    &ldquo;strategy&rdquo; object is usually stateless&thinsp;&mdash;&thinsp;it
    encapsulates an algorithm but no data. It defines <em>how</em> an object
    behaves but not <em>what</em> it is.</p>
<p>Components are a bit more self-important. They often hold state
that describes the object and help define its actual identity.
However, the line may blur. You may have some components that
don&#x2019;t need any local state. In that case, you&#x2019;re free to use the
same component <em>instance</em> across multiple container objects. At
that point, it really is behaving more akin to a strategy.</p>
</li>
</ul>
<p class="footer">&copy; 2009-2013 Bob Nystrom</p>
</div>
</body>
<script src="jquery-1.10.1.min.js"></script>
<script src="script.js"></script>
</html>
